<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAST: Tie Constraints</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structural_example_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tie Constraints </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#init_mesh">Mesh Generation</a></li>
<li class="level1"><a href="#init_eq_sys">System Initialization</a></li>
<li class="level1"><a href="#init_bc">Dirichlet Boundary Condition</a></li>
<li class="level1"><a href="#init_coupling">Kinematic Coupling</a></li>
<li class="level1"><a href="#init_loads">Load and Property Definition</a></li>
<li class="level1"><a href="#sol">Solution</a></li>
</ul>
</div>
<div class="textblock"><p>This example solves a cantilever rectangular plate with a uniformly distributed load on the top of the plate.</p>
<p>An inclined section is created as a separate mesh and connected to the plate using tie constraints at the shared edge.</p>
<p>For direct solver, run with options: -ksp_type preonly -pc_type lu</p>
<h1><a class="anchor" id="init_mesh"></a>
Mesh Generation</h1>
<pre class="fragment"> This function initializes the mesh data stucture. 
</pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> init_mesh(libMesh::ReplicatedMesh&amp; mesh) {</div></div><!-- fragment --><p> A square <img class="formulaInl" alt="$ 0.3m \times 0.3m $" src="form_0.png"/> mesh is created with <code>QUAD4</code> elements. </p><div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">length = 0.3,</div><div class="line">width  = 0.3,</div><div class="line">pi     = acos(-1.);</div></div><!-- fragment --><p> The mesh generation tools from libMesh are used to initialize this section of the mesh. A <img class="formulaInl" alt="$ 10\times 10 $" src="form_1.png"/> mesh of QUAD4 elements is used for discretization. </p><div class="fragment"><div class="line">libMesh::MeshTools::Generation::build_square(mesh, 10, 10, 0.0, length, 0.0, width, libMesh::QUAD4);</div></div><!-- fragment --><p> Next, a section of the same dimension and mesh density is created and added to the <code>mesh</code> object. This section is attached to the right side of the cantilever section (created above) using kinematic constraints. The section is inclined at a <img class="formulaInl" alt="$ 45^\circ $" src="form_2.png"/> angle.</p>
<div class="image">
<img src="example_4_mesh.png" alt="example_4_mesh.png"/>
</div>
<div class="fragment"><div class="line">std::map&lt;const libMesh::Node*, libMesh::Node*&gt;</div><div class="line">node_map;</div></div><!-- fragment --><p> add new nodes </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">n_it   =  mesh.nodes_begin(),</div><div class="line">n_end  =  mesh.nodes_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; n_it != n_end; n_it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node* nd = *n_it;</div><div class="line">    libMesh::Node* new_nd   = libMesh::Node::build(*nd, libMesh::DofObject::invalid_id).release();</div></div><!-- fragment --><p> add new node to the map so that we will be able to use it during element creation below </p><div class="fragment"><div class="line">node_map[nd] = new_nd;</div></div><!-- fragment --><p> modify the coordinates to include the incline. </p><div class="fragment"><div class="line">    (*new_nd)(0)  = length + (*nd)(0)*cos(pi/4.);</div><div class="line">    (*new_nd)(1) += 0.;</div><div class="line">    (*new_nd)(2)  = (*nd)(0)*sin(pi/4.);</div><div class="line">}</div></div><!-- fragment --><p> add new nodes </p><div class="fragment"><div class="line">std::map&lt;const libMesh::Node*, libMesh::Node*&gt;::iterator</div><div class="line">nd_map_it  = node_map.begin(),</div><div class="line">nd_map_end = node_map.end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; nd_map_it != nd_map_end; nd_map_it++)</div><div class="line">    mesh.add_node(nd_map_it-&gt;second);</div></div><!-- fragment --><p> add new elements </p><div class="fragment"><div class="line">std::set&lt;libMesh::Elem*&gt; elems;</div><div class="line"></div><div class="line">libMesh::MeshBase::const_element_iterator</div><div class="line">e_it    =  mesh.elements_begin(),</div><div class="line">e_end   =  mesh.elements_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; e_it != e_end; e_it++) {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> libMesh::Elem* e = *e_it;</div><div class="line">    libMesh::Elem* new_e   = libMesh::Elem::build(e-&gt;type()).release();</div></div><!-- fragment --><p> set nodes </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;e-&gt;n_nodes(); i++)</div><div class="line">    new_e-&gt;set_node(i) = node_map[e-&gt;node_ptr(i)];</div></div><!-- fragment --><p> set subdomain ID to 1 </p><div class="fragment"><div class="line">new_e-&gt;subdomain_id() = e-&gt;subdomain_id()+1;</div></div><!-- fragment --><p> set boundary IDs </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> n=0; n&lt;e-&gt;n_sides(); n++) {</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (mesh.boundary_info-&gt;n_boundary_ids(e, n)) {</div></div><!-- fragment --><p> add the boundary tags to the panel mesh </p><div class="fragment"><div class="line">            std::vector&lt;libMesh::boundary_id_type&gt; bc_ids;</div><div class="line">            mesh.boundary_info-&gt;boundary_ids(e, n, bc_ids);</div><div class="line">            </div><div class="line">            <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bid=0; bid &lt; bc_ids.size(); bid++)</div><div class="line">                mesh.boundary_info-&gt;add_side(new_e, n, bc_ids[bid]+4);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    elems.insert(new_e);</div><div class="line">}</div><div class="line"></div><div class="line">std::set&lt;libMesh::Elem*&gt;::iterator</div><div class="line">elem_set_it  = elems.begin(),</div><div class="line">elem_set_end = elems.end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; elem_set_it != elem_set_end; elem_set_it++)</div><div class="line">    mesh.add_elem(*elem_set_it);</div><div class="line"></div><div class="line">mesh.prepare_for_use();</div></div><!-- fragment --><p> the boundaries are indentified using the following tags. </p><div class="fragment"><div class="line">    mesh.boundary_info-&gt;sideset_name(4) = <span class="stringliteral">&quot;bottom2&quot;</span>;</div><div class="line">    mesh.boundary_info-&gt;sideset_name(5) = <span class="stringliteral">&quot;right2&quot;</span>;</div><div class="line">    mesh.boundary_info-&gt;sideset_name(6) = <span class="stringliteral">&quot;top2&quot;</span>;</div><div class="line">    mesh.boundary_info-&gt;sideset_name(7) = <span class="stringliteral">&quot;left2&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div></div><!-- fragment --><p>Initialize libMesh library. </p><div class="fragment"><div class="line">libMesh::LibMeshInit init(argc, argv);</div></div><!-- fragment --><p> A replicated mesh is used, which will store the entire mesh on all elements. </p><div class="fragment"><div class="line">libMesh::ReplicatedMesh mesh(init.comm());</div></div><!-- fragment --><p> Initialize the mesh using the function defined above. </p><div class="fragment"><div class="line">init_mesh(mesh);</div><div class="line">mesh.print_info();</div></div><!-- fragment --> <h1><a class="anchor" id="init_eq_sys"></a>
System Initialization</h1>
<div class="fragment"></div><!-- fragment --><p> Create EquationSystems object, which is a container for multiple systems of equations that are defined on a given mesh. </p><div class="fragment"><div class="line">libMesh::EquationSystems equation_systems(mesh);</div></div><!-- fragment --><p> Add system of type <a class="el" href="class_m_a_s_t_1_1_nonlinear_system.html" title="This class implements a system for solution of nonlinear systems. ">MAST::NonlinearSystem</a> (which wraps libMesh::NonlinearImplicitSystem) to the EquationSystems container. We name the system "structural" and also get a reference to the system so we can easily reference it later. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a> &amp; system = equation_systems.add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;structural&quot;</span>);</div></div><!-- fragment --><p> Create a finite element type for the system. Here we use first order Lagrangian-type finite elements. </p><div class="fragment"><div class="line">libMesh::FEType fetype(libMesh::FIRST, libMesh::LAGRANGE);</div></div><!-- fragment --><p> Initialize the system to the correct set of variables for a structural analysis. In libMesh this is analogous to adding variables (each with specific finite element type/order to the system for a particular system of equations. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a> structural_system(system,</div><div class="line">                                                       system.name(),</div><div class="line">                                                       fetype);</div></div><!-- fragment --><p> Initialize a new structural discipline using equation_systems. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a> discipline(equation_systems);</div></div><!-- fragment --> <h1><a class="anchor" id="init_bc"></a>
Dirichlet Boundary Condition</h1>
<div class="fragment"></div><!-- fragment --><p> Create and add boundary conditions to the structural system. A Dirichlet BC adds fixed displacement BCs. Here we use the side boundary ID numbering created by the libMesh generator to clamp the edge of the mesh along x=0.0. We apply the BC to all variables on each node in the subdomain ID 0, which clamps this edge. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a> clamped_edge0, clamped_edge1, clamped_edge2, clamped_edge3;    <span class="comment">// Create BC object.</span></div><div class="line">std::vector&lt;unsigned int&gt; vars = {0, 1, 2, 3, 4, 5};</div><div class="line">clamped_edge3.<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(3, vars);   <span class="comment">// Assign boundary ID and variables to constrain</span></div><div class="line">discipline.add_dirichlet_bc(3, clamped_edge3);     <span class="comment">// Attach boundary condition to discipline</span></div><div class="line">discipline.init_system_dirichlet_bc(system);      <span class="comment">// Initialize the BC in the system.</span></div></div><!-- fragment --><p> Initialize the equation system since we now know the size of our system matrices (based on mesh, element type, variables in the structural_system) as well as the setup of dirichlet boundary conditions. This initialization process is basically a pre-processing step to preallocate storage and spread it across processors. </p><div class="fragment"></div><!-- fragment --> <h1><a class="anchor" id="init_coupling"></a>
Kinematic Coupling</h1>
<div class="fragment"></div><!-- fragment --><p>The tie constraints are added through the DofConstraintRow functionality in libMesh. Here, constraint equations are specified between degrees-of-freedom (DoFs). The first step in the coupling is identified through a geometric search which identifies the nodes on the respective boundaries of master and slave mesh that need to be coupled with each other. Here, the right boundary (boundary id 1) of the cantilevered plate is connected to the left boundary (boundary id 7) of the unconnected domain. Once the nodes have been identified, the next step is to identify the constraint equations that will define the dependence of the slave nodes on the master nodes. This is done by the <code>MeshCouplingBase</code> class. The constraint equations are then provided to libMesh through this ad-hoc class <code>Constr</code> below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Constr: <span class="keyword">public</span> libMesh::System::Constraint {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Constr(<a class="code" href="class_m_a_s_t_1_1_kinematic_coupling.html">MAST::KinematicCoupling</a>&amp; kin_coupling): _kin_coupling(kin_coupling) {}</div><div class="line">    <span class="keyword">virtual</span> ~Constr () {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> constrain () { _kin_coupling.add_dof_constraints_to_dof_map(); }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_kinematic_coupling.html">MAST::KinematicCoupling</a>&amp; _kin_coupling;</div><div class="line">};</div></div><!-- fragment --><p>The <code>MeshCouplingBase</code> class will used to couple the boudnary ID 7 as the slave to the boundary ID 1 as the master. A geometric search will be used to identify node couplings within a circular radius of 0.005 m. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_mesh_coupling_base.html">MAST::MeshCouplingBase</a> mesh_coupling(structural_system);</div></div><!-- fragment --><p> This call will lead to a master-slave boundary-to-boundary coupling. This can be uncommented and the next boundary-to-subdomain call can be commented to enable this call. mesh_coupling.add_master_and_slave_boundary_coupling(1, 7, .005); </p><div class="fragment"></div><!-- fragment --><p> the mesh can also be coupled using slave-boundary to master-subdomain coupling. </p><div class="fragment"><div class="line">mesh_coupling.add_slave_boundary_and_master_subdomain_coupling(0, 7, .005);</div></div><!-- fragment --><p> The <code>KinematicCoupling</code> class uses the search results to create the kinematic constraints (or tie-constraints) for libMesh::DofMap </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_kinematic_coupling.html">MAST::KinematicCoupling</a> kin_coupling(structural_system);</div><div class="line">kin_coupling.add_master_and_slave(mesh_coupling.get_node_couplings(), <span class="keyword">true</span>);</div></div><!-- fragment --><p> This class will is provided to libMesh::System and it will be called by libMesh when the system is initialized. </p><div class="fragment"><div class="line">Constr kc(kin_coupling);</div><div class="line">system.attach_constraint_object(kc);</div></div><!-- fragment --><p> This will initialize the DoFs, Dirichlet Constraints and kinematic constraints. </p><div class="fragment"><div class="line">equation_systems.init();</div><div class="line">equation_systems.print_info();</div></div><!-- fragment --> <h1><a class="anchor" id="init_loads"></a>
Load and Property Definition</h1>
<div class="fragment"></div><!-- fragment --><p> Create parameters. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> thickness(<span class="stringliteral">&quot;th&quot;</span>,   0.001);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> E(<span class="stringliteral">&quot;E&quot;</span>,            72.e9);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> nu(<span class="stringliteral">&quot;nu&quot;</span>,           0.33);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> rho(<span class="stringliteral">&quot;rho&quot;</span>,        2700.);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> kappa(<span class="stringliteral">&quot;kappa&quot;</span>,    5./6.);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> alpha(<span class="stringliteral">&quot;alpha&quot;</span>,   1.5e-5);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> zero(<span class="stringliteral">&quot;zero&quot;</span>,        0.0);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> pressure1(<span class="stringliteral">&quot;p&quot;</span>,    1.0e2);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> pressure2(<span class="stringliteral">&quot;p&quot;</span>,   -1.0e2);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> temperature(<span class="stringliteral">&quot;T&quot;</span>,    0.0);</div></div><!-- fragment --><p> Create ConstantFieldFunctions used to spread parameters throughout the model. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> th_f(<span class="stringliteral">&quot;h&quot;</span>, thickness);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> E_f(<span class="stringliteral">&quot;E&quot;</span>, E);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> nu_f(<span class="stringliteral">&quot;nu&quot;</span>, nu);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> rho_f(<span class="stringliteral">&quot;rho&quot;</span>, rho);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> kappa_f(<span class="stringliteral">&quot;kappa&quot;</span>, kappa);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> alpha_f(<span class="stringliteral">&quot;alpha_expansion&quot;</span>, alpha);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> off_f(<span class="stringliteral">&quot;off&quot;</span>, zero);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> pressure1_f(<span class="stringliteral">&quot;pressure&quot;</span>, pressure1);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> pressure2_f(<span class="stringliteral">&quot;pressure&quot;</span>, pressure2);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> temperature_f(<span class="stringliteral">&quot;temperature&quot;</span>, temperature);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> ref_temp_f(<span class="stringliteral">&quot;ref_temperature&quot;</span>, zero);</div></div><!-- fragment --><p> Initialize load. The same pressure is applied to both sub-domains 1 and 2. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a> surface_pressure1(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a> surface_pressure2(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line">surface_pressure1.add(pressure1_f);</div><div class="line">surface_pressure2.add(pressure2_f);</div><div class="line">discipline.add_volume_load(0, surface_pressure1);</div><div class="line">discipline.add_volume_load(1, surface_pressure2);</div><div class="line"></div><div class="line"><a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a> temperature_load(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14a86f299c7a235fa4f58e87c412e209079">MAST::TEMPERATURE</a>);</div><div class="line">temperature_load.add(temperature_f);</div><div class="line">temperature_load.add(ref_temp_f);</div><div class="line">discipline.add_volume_load(0, temperature_load);</div><div class="line">discipline.add_volume_load(1, temperature_load);</div></div><!-- fragment --><p> Create the material property card ("card" is NASTRAN lingo) and the relevant parameters to it. An isotropic material needs elastic modulus (E) and Poisson ratio (nu) to describe its behavior. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_isotropic_material_property_card.html">MAST::IsotropicMaterialPropertyCard</a> material;</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(E_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(nu_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(kappa_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(alpha_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(rho_f);</div></div><!-- fragment --><p> Create the section property card. Attach all property values. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a> section;</div><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(th_f);</div><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(off_f);</div></div><!-- fragment --><p> Attach material to the card. </p><div class="fragment"><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html#a902ba3f2c2a23289a7c394ccb8cc8162">set_material</a>(material);</div></div><!-- fragment --><p> Initialize the specify the subdomain in the mesh that it applies to. </p><div class="fragment"><div class="line">discipline.set_property_for_subdomain(0, section);</div><div class="line">discipline.set_property_for_subdomain(1, section);</div></div><!-- fragment --> <h1><a class="anchor" id="sol"></a>
Solution</h1>
<div class="fragment"></div><!-- fragment --><p> Create nonlinear assembly object and set the discipline and structural_system. Create reference to system. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_implicit_assembly.html">MAST::NonlinearImplicitAssembly</a> assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_nonlinear_assembly_elem_operations.html">MAST::StructuralNonlinearAssemblyElemOperations</a> elem_ops;</div><div class="line">assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(discipline, structural_system);</div><div class="line">elem_ops.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(discipline, structural_system);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&amp; nonlinear_system = assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#abdff8292b4929a3aa7276c639a8d05e3">system</a>();</div></div><!-- fragment --><p> Zero the solution before solving. </p><div class="fragment"><div class="line">nonlinear_system.solution-&gt;zero();</div><div class="line">nonlinear_system.<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aaaed1f33d18591f0f380516e1e2fbb8c">solve</a>(elem_ops, assembly);</div></div><!-- fragment --><p> post-process the stress for plotting. This is done through the output and stress assembly classes. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html">MAST::StressStrainOutputBase</a> stress;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_stress_assembly.html">MAST::StressAssembly</a>         stress_assembly;</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>         (discipline, structural_system);</div><div class="line">stress_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(discipline, structural_system);</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_output_assembly_elem_operations.html#ad7ce0a9393f174a5d19a52e6736ae988">set_participating_elements_to_all</a>();</div><div class="line">stress_assembly.<a class="code" href="class_m_a_s_t_1_1_stress_assembly.html#a102f82da5f427b2702768d556d657ba8">update_stress_strain_data</a>(stress, *system.solution);</div></div><!-- fragment --><p>Following is a the displacement contour of the panel with the undeformed mesh plotted for reference. The displacement continuity at the interface is properly enforced.</p>
<div class="image">
<img src="example_4_uz_contour.png" alt="example_4_uz_contour.png"/>
</div>
<div class="fragment"><div class="line">libMesh::ExodusII_IO(mesh).write_equation_systems(<span class="stringliteral">&quot;panel.exo&quot;</span>, equation_systems);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="TutorialsPage.html">Tutorials for MAST</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
