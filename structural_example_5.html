<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAST: 2D Level-set topology optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structural_example_5.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">2D Level-set topology optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ex_5_init_mesh">Mesh Generation</a><ul><li class="level2"><a href="#ex_5_inplane_mesh">Inplane problem</a></li>
<li class="level2"><a href="#ex_5_bracket_mesh">Bracket</a></li>
<li class="level2"><a href="#ex_5_eyebar_mesh">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_system_discipline">System and Discipline</a></li>
<li class="level1"><a href="#ex_5_dirichlet">Dirichlet Constraints</a><ul><li class="level2"><a href="#ex_5_inplane_dirichlet">Inplane</a></li>
<li class="level2"><a href="#ex_5_truss_dirichlet">Truss</a></li>
<li class="level2"><a href="#ex_5_bracket_dirichlet">Bracket</a></li>
<li class="level2"><a href="#ex_5_eyebar_dirichlet">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_loading">Loading</a><ul><li class="level2"><a href="#ex_5_inplane_loading">Inplane</a></li>
<li class="level2"><a href="#ex_5_bracket_loading">Bracket</a></li>
<li class="level2"><a href="#ex_5_eyebar_loading">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_properties">Properties</a><ul><li class="level2"><a href="#ex_5_material_properties">Material Properties</a></li>
<li class="level2"><a href="#ex_5_section_properties">Section Properties</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_initial_solution">Initial Level Set</a><ul><li class="level2"><a href="#ex_5_inplane_initial_level_set">Inplane</a></li>
<li class="level2"><a href="#ex_5_truss_initial_level_set">Truss</a></li>
<li class="level2"><a href="#ex_5_bracket_initial_level_set">Bracket</a></li>
<li class="level2"><a href="#ex_5_eyebar_initial_level_set">Eyebar</a></li>
<li class="level2"><a href="#ex_5_design_variable_init">Design Variables</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_analysis">Function Evaluation and Sensitivity</a><ul><li class="level2"><a href="#ex_5_element_error_metric">Element Error Metric</a></li>
<li class="level2"><a href="#ex_5_function_evaluation">Function Evaluation</a></li>
<li class="level2"><a href="#ex_5_volume_sensitivity">Sensitivity of Material Volume</a></li>
<li class="level2"><a href="#ex_5_stress_sensitivity">Sensitivity of Stress and Eigenvalues</a></li>
<li class="level2"><a href="#ex_5_design_output">Output of Design Iterate</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_5_initialization">Initialization</a><ul><li class="level2"><a href="#ex_5_constructor">Constructor</a></li>
<li class="level2"><a href="#ex_5_destructor">Destructor</a></li>
<li class="level2"><a href="#ex_5_wrappers_snopt">Wrappers for SNOPT</a></li>
<li class="level2"><a href="#ex_5_main">Main function</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This example computes the optimal topology of a structure subject to specified boundary conditions (Dirichlet and Neumann).</p>
<p>A level-set function is used to implicitly define the geometry inside a mesh using the immersed boundary approach.</p>
<p>Level Set Mesh Function </p><div class="fragment"><div class="line"><span class="keyword">class </span>PhiMeshFunction:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PhiMeshFunction():</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(<span class="stringliteral">&quot;phi&quot;</span>), _phi(nullptr) { }</div><div class="line">    <span class="keyword">virtual</span> ~PhiMeshFunction(){ <span class="keywordflow">if</span> (_phi) <span class="keyword">delete</span> _phi;}</div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> init(<a class="code" href="class_m_a_s_t_1_1_system_initialization.html">MAST::SystemInitialization</a>&amp; sys, <span class="keyword">const</span> libMesh::NumericVector&lt;Real&gt;&amp; sol) {</div><div class="line">        <span class="keywordflow">if</span> (!_phi) _phi = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>(sys, <span class="stringliteral">&quot;phi&quot;</span>);</div><div class="line">        <span class="keywordflow">else</span> _phi-&gt;clear();</div><div class="line">        _phi-&gt;init(sol);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>&amp; get_mesh_function() {<span class="keywordflow">return</span> *_phi;}</div><div class="line">    </div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        libmesh_assert(_phi);</div><div class="line">        <a class="code" href="mast__data__types_8h.html#abc8ad2bc4221d7400e5306159e28e588">RealVectorX</a> v1;</div><div class="line">        (*_phi)(p, t, v1);</div><div class="line">        v = v1(0);</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a> *_phi;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ElementParameterDependence:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_assembly_base_1_1_elem_parameter_dependence.html">MAST::AssemblyBase::ElemParameterDependence</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ElementParameterDependence(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>&amp; filter):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::AssemblyBase::ElemParameterDependence(true), _filter(filter) {}</div><div class="line">    <span class="keyword">virtual</span> ~ElementParameterDependence() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> if_elem_depends_on_parameter(<span class="keyword">const</span> libMesh::Elem&amp; e,</div><div class="line">                                              <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; p)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a></div><div class="line">        &amp;p_ls = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>&amp;<span class="keyword">&gt;</span>(p);</div><div class="line">        </div><div class="line">        <span class="keywordflow">return</span> _filter.if_elem_in_domain_of_influence(e, *p_ls.<a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html#aea6c707fc12f646008d59d124138bd3c">level_set_node</a>());</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>&amp; _filter;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>TopologyOptimizationLevelSet2D:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_function_evaluation.html">MAST::FunctionEvaluation</a> {</div><div class="line">    </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    </div><div class="line">    <span class="keywordtype">bool</span>                                      _initialized;</div><div class="line">    MAST::Examples::GetPotWrapper&amp;            _input;</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _length;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _height;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _obj_scaling;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _stress_penalty;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _perimeter_penalty;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _stress_lim;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _p_val, _vm_rho;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _ref_eig_val;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                              _n_eig_vals;</div><div class="line">    </div><div class="line">    libMesh::UnstructuredMesh*                _mesh;</div><div class="line">    libMesh::UnstructuredMesh*                _level_set_mesh;</div><div class="line">    </div><div class="line">    libMesh::EquationSystems*                 _eq_sys;</div><div class="line">    libMesh::EquationSystems*                 _level_set_eq_sys;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>*                    _sys;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>*                    _level_set_sys;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>*                    _level_set_sys_on_str_mesh;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>*                    _indicator_sys;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a>*     _sys_init;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_level_set_system_initialization.html">MAST::LevelSetSystemInitialization</a>*       _level_set_sys_init_on_str_mesh;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_level_set_system_initialization.html">MAST::LevelSetSystemInitialization</a>*       _level_set_sys_init;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_heat_conduction_system_initialization.html">MAST::HeatConductionSystemInitialization</a>* _indicator_sys_init;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>*              _discipline;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>*              _indicator_discipline;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_level_set_discipline.html">MAST::LevelSetDiscipline</a>*                 _level_set_discipline;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>*                         _filter;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_material_property_card_base.html">MAST::MaterialPropertyCardBase</a>*           _m_card;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_element_property_card_base.html">MAST::ElementPropertyCardBase</a>*            _p_card;</div><div class="line">    </div><div class="line">    PhiMeshFunction*                          _level_set_function;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_level_set_boundary_velocity.html">MAST::LevelSetBoundaryVelocity</a>*           _level_set_vel;</div><div class="line">    libMesh::ExodusII_IO*                     _output;</div><div class="line">    </div><div class="line">    libMesh::FEType                           _fetype;</div><div class="line">    libMesh::FEType                           _level_set_fetype;</div><div class="line">    </div><div class="line">    std::vector&lt;MAST::Parameter*&gt;             _params_for_sensitivity;</div><div class="line">    std::map&lt;std::string, MAST::Parameter*&gt;   _parameters;</div><div class="line">    std::set&lt;MAST::FunctionBase*&gt;             _field_functions;</div><div class="line">    std::set&lt;MAST::BoundaryConditionBase*&gt;    _boundary_conditions;</div><div class="line">    std::set&lt;unsigned int&gt;                    _dv_dof_ids;</div><div class="line">    </div><div class="line">    std::vector&lt;std::pair&lt;unsigned int, MAST::Parameter*&gt;&gt;  _dv_params;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --> <h1><a class="anchor" id="ex_5_init_mesh"></a>
Mesh Generation</h1>
<p>This creates the mesh for the specified problem type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh() {</div></div><!-- fragment --><p> The mesh is created using classes written in <a class="el" href="namespace_m_a_s_t.html">MAST</a>. The particular mesh to be used can be selected using the input parameter <code>mesh=val</code>, where <code>val</code> can be one of the following:</p><ul>
<li><code>inplane</code> inplane structure with load on top and left and right boundaries constrained</li>
<li><code>bracket</code> L-bracket</li>
</ul>
<div class="fragment"><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, bracket}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_mesh_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_mesh_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_mesh_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_inplane_mesh"></a>
Inplane problem</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_inplane()  {</div><div class="line">    </div><div class="line">    _mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div></div><!-- fragment --><p>identify the element type from the input file or from the order of the element</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">nx_divs = _input(<span class="stringliteral">&quot;nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along x-axis&quot;</span>, 20),</div><div class="line">ny_divs = _input(<span class="stringliteral">&quot;ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along y-axis&quot;</span>, 20);</div><div class="line"></div><div class="line">_length = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">_height = _input(<span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3);</div><div class="line"></div><div class="line">std::string</div><div class="line">t = _input(<span class="stringliteral">&quot;elem_type&quot;</span>, <span class="stringliteral">&quot;type of geometric element in the mesh&quot;</span>, <span class="stringliteral">&quot;quad4&quot;</span>);</div><div class="line"></div><div class="line">libMesh::ElemType</div><div class="line">e_type = libMesh::Utility::string_to_enum&lt;libMesh::ElemType&gt;(t);</div></div><!-- fragment --><p>if high order FE is used, libMesh requires atleast a second order geometric element.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::QUAD4)</div><div class="line">    e_type = libMesh::QUAD9;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::TRI3)</div><div class="line">    e_type = libMesh::TRI6;</div></div><!-- fragment --><p>initialize the mesh with one element</p>
<div class="fragment"><div class="line">libMesh::MeshTools::Generation::build_square(*_mesh,</div><div class="line">                                             nx_divs, ny_divs,</div><div class="line">                                             0, _length,</div><div class="line">                                             0, _height,</div><div class="line">                                             e_type);</div></div><!-- fragment --><p>mesh on which the level-set function is defined</p>
<div class="fragment"><div class="line">_level_set_mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div><div class="line"></div><div class="line">nx_divs = _input(<span class="stringliteral">&quot;level_set_nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along x-axis&quot;</span>, 10);</div><div class="line">ny_divs = _input(<span class="stringliteral">&quot;level_set_ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along y-axis&quot;</span>, 10);</div><div class="line">e_type  = libMesh::QUAD4;</div></div><!-- fragment --><p> initialize the mesh with one element </p><div class="fragment"><div class="line">    libMesh::MeshTools::Generation::build_square(*_level_set_mesh,</div><div class="line">                                                 nx_divs, ny_divs,</div><div class="line">                                                 0, _length,</div><div class="line">                                                 0, _height,</div><div class="line">                                                 e_type);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_bracket_mesh"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_bracket() {</div><div class="line"></div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        nx_divs = _input(<span class="stringliteral">&quot;nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along x-axis&quot;</span>, 20),</div><div class="line">        ny_divs = _input(<span class="stringliteral">&quot;ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along y-axis&quot;</span>, 20);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (nx_divs%10 != 0 || ny_divs%10 != 0) libmesh_error();</div><div class="line">    }</div><div class="line">    </div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        nx_divs = _input(<span class="stringliteral">&quot;level_set_nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along x-axis&quot;</span>, 10),</div><div class="line">        ny_divs = _input(<span class="stringliteral">&quot;level_set_ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along y-axis&quot;</span>, 10);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (nx_divs%10 != 0 || ny_divs%10 != 0) libmesh_error();</div><div class="line">        </div><div class="line">    }</div><div class="line"></div><div class="line">    _init_mesh_inplane();</div><div class="line">    _delete_elems_from_bracket_mesh(*_mesh);</div><div class="line">    _delete_elems_from_bracket_mesh(*_level_set_mesh);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _delete_elems_from_bracket_mesh(libMesh::MeshBase &amp;mesh) {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    tol     = 1.e-12,</div><div class="line">    x       = -1.,</div><div class="line">    y       = -1.,</div><div class="line">    length  = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">    width   = _input( <span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3),</div><div class="line">    l_frac  = 0.4,</div><div class="line">    w_frac  = 0.4,</div><div class="line">    x_lim   = length * l_frac,</div><div class="line">    y_lim   =  width * (1.-w_frac);</div></div><!-- fragment --><p>now, remove elements that are outside of the L-bracket domain</p>
<div class="fragment"><div class="line">libMesh::MeshBase::element_iterator</div><div class="line">e_it   = mesh.elements_begin(),</div><div class="line">e_end  = mesh.elements_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; e_it!=e_end; e_it++) {</div><div class="line">    </div><div class="line">    libMesh::Elem* elem = *e_it;</div><div class="line">    x = length;</div><div class="line">    y = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elem-&gt;n_nodes(); i++) {</div><div class="line">        <span class="keyword">const</span> libMesh::Node&amp; n = elem-&gt;node_ref(i);</div><div class="line">        <span class="keywordflow">if</span> (x &gt; n(0)) x = n(0);</div><div class="line">        <span class="keywordflow">if</span> (y &lt; n(1)) y = n(1);</div><div class="line">    }</div></div><!-- fragment --><p>delete element if the lowest x,y locations are outside of the bracket domain</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (x &gt;= x_lim &amp;&amp; y&lt;= y_lim)</div><div class="line">        mesh.delete_elem(elem);</div><div class="line">}</div><div class="line"></div><div class="line">mesh.prepare_for_use();</div></div><!-- fragment --><p>add the two additional boundaries to the boundary info so that we can apply loads on them</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    facing_right = <span class="keyword">false</span>,</div><div class="line">    facing_down  = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    e_it   = mesh.elements_begin();</div><div class="line">    e_end  = mesh.elements_end();</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> ( ; e_it != e_end; e_it++) {</div><div class="line">        </div><div class="line">        libMesh::Elem* elem = *e_it;</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!elem-&gt;on_boundary()) <span class="keywordflow">continue</span>;</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elem-&gt;n_sides(); i++) {</div><div class="line">            </div><div class="line">            <span class="keywordflow">if</span> (elem-&gt;neighbor_ptr(i)) <span class="keywordflow">continue</span>;</div><div class="line">            </div><div class="line">            std::unique_ptr&lt;libMesh::Elem&gt; s(elem-&gt;side_ptr(i).release());</div><div class="line">            </div><div class="line">            <span class="keyword">const</span> libMesh::Point p = s-&gt;centroid();</div><div class="line">            </div><div class="line">            facing_right = <span class="keyword">true</span>;</div><div class="line">            facing_down  = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;s-&gt;n_nodes(); j++) {</div><div class="line">                <span class="keyword">const</span> libMesh::Node&amp; n = s-&gt;node_ref(j);</div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (n(0) &lt; x_lim ||  n(1) &gt; y_lim) {</div><div class="line">                    facing_right = <span class="keyword">false</span>;</div><div class="line">                    facing_down  = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::fabs(n(0) - p(0)) &gt; tol)</div><div class="line">                    facing_right = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::fabs(n(1) - p(1)) &gt; tol)</div><div class="line">                    facing_down = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keywordflow">if</span> (facing_right) mesh.boundary_info-&gt;add_side(elem, i, 4);</div><div class="line">            <span class="keywordflow">if</span> (facing_down) mesh.boundary_info-&gt;add_side(elem, i, 5);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    mesh.boundary_info-&gt;sideset_name(4) = <span class="stringliteral">&quot;facing_right&quot;</span>;</div><div class="line">    mesh.boundary_info-&gt;sideset_name(5) = <span class="stringliteral">&quot;facing_down&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_eyebar_mesh"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_eye_bar() {</div><div class="line">    </div><div class="line">    _mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div></div><!-- fragment --><p>identify the element type from the input file or from the order of the element</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_radial_divs  = _input(<span class="stringliteral">&quot;n_radial_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along radial direction&quot;</span>, 20),</div><div class="line">n_quarter_divs = _input(<span class="stringliteral">&quot;n_quarter_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along height&quot;</span>, 20);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">radius   = 1.5,</div><div class="line">h_ratio  = _input(<span class="stringliteral">&quot;h_ratio&quot;</span>, <span class="stringliteral">&quot;ratio of radial element size at cylinder and at edge&quot;</span>, 2);</div><div class="line">_height  = 8.;</div><div class="line">_length  = _height*2;</div><div class="line"></div><div class="line">std::string</div><div class="line">t = _input(<span class="stringliteral">&quot;elem_type&quot;</span>, <span class="stringliteral">&quot;type of geometric element in the mesh&quot;</span>, <span class="stringliteral">&quot;quad4&quot;</span>);</div><div class="line"></div><div class="line">libMesh::ElemType</div><div class="line">e_type = libMesh::Utility::string_to_enum&lt;libMesh::ElemType&gt;(t);</div></div><!-- fragment --><p>if high order FE is used, libMesh requires atleast a second order geometric element.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::QUAD4)</div><div class="line">    e_type = libMesh::QUAD9;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::TRI3)</div><div class="line">    e_type = libMesh::TRI6;</div><div class="line"></div><div class="line">MAST::Examples::CylinderMesh2D cylinder;</div><div class="line">cylinder.mesh(radius, _height/2.,</div><div class="line">              n_radial_divs, n_quarter_divs, h_ratio,</div><div class="line">              *_mesh, e_type,</div><div class="line">              <span class="keyword">true</span>, _height, n_quarter_divs*2);</div></div><!-- fragment --><p>add the boundary ids for Dirichlet conditions</p>
<div class="fragment"><div class="line">libMesh::MeshBase::const_element_iterator</div><div class="line">e_it   = _mesh-&gt;elements_begin(),</div><div class="line">e_end  = _mesh-&gt;elements_end();</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol  = radius * 1.e-8;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; e_it != e_end; e_it++) {</div><div class="line">    </div><div class="line">    libMesh::Elem* elem = *e_it;</div><div class="line">    </div><div class="line">    std::unique_ptr&lt;libMesh::Elem&gt; edge(elem-&gt;side_ptr(1));</div><div class="line">    libMesh::Point p = edge-&gt;centroid();</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (std::fabs(p(0)-_height*1.5) &lt; tol &amp;&amp;</div><div class="line">        std::fabs(p(1)) &lt;= 1.) <span class="comment">// on the right edge</span></div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(elem, 1, 0);</div></div><!-- fragment --><p> check for the circumference of the circle where load will be applied </p><div class="fragment"><div class="line">    edge.reset(elem-&gt;side_ptr(3).release());</div><div class="line">    p = edge-&gt;centroid();</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((std::fabs(p.norm()-radius) &lt; 1.e-2) &amp;&amp;</div><div class="line">        p(0) &lt; 0.) <span class="comment">// left semi-circle</span></div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(elem, 3, 5);</div><div class="line">}</div><div class="line"></div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(0) = <span class="stringliteral">&quot;dirichlet&quot;</span>;</div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(5) = <span class="stringliteral">&quot;load&quot;</span>;</div></div><!-- fragment --><p> mesh on which the level-set function is defined </p><div class="fragment"><div class="line">_level_set_mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div><div class="line"></div><div class="line">n_radial_divs  = _input(<span class="stringliteral">&quot;level_set_n_radial_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along radial direction&quot;</span>, 10),</div><div class="line">n_quarter_divs = _input(<span class="stringliteral">&quot;level_set_n_quarter_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along height&quot;</span>, 10);</div><div class="line">e_type  = libMesh::QUAD4;</div></div><!-- fragment --><p>initialize the mesh with one element</p>
<div class="fragment"><div class="line">    cylinder.mesh(radius, _height/2,</div><div class="line">                  n_radial_divs, n_quarter_divs, h_ratio,</div><div class="line">                  *_level_set_mesh, e_type,</div><div class="line">                  <span class="keyword">true</span>, _height, n_quarter_divs*2);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_system_discipline"></a>
System and Discipline</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_system_and_discipline() {</div></div><!-- fragment --><p>make sure that the mesh has been initialized</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh);</div></div><!-- fragment --><p>create the equation system</p>
<div class="fragment"><div class="line">_eq_sys    = <span class="keyword">new</span>  libMesh::EquationSystems(*_mesh);</div></div><!-- fragment --><p>create the libmesh system and set the preferences for structural eigenvalue problems</p>
<div class="fragment"><div class="line">_sys       = &amp;(_eq_sys-&gt;add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;structural&quot;</span>));</div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a081daabdb69d1a500c926762fb1c6038">set_eigenproblem_type</a>(libMesh::GHEP);</div></div><!-- fragment --><p>initialize the system to the right set of variables</p>
<div class="fragment"><div class="line">_sys_init       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a>(*_sys,</div><div class="line">                                                           _sys-&gt;name(),</div><div class="line">                                                           _fetype);</div><div class="line">_discipline     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>(*_eq_sys);</div></div><!-- fragment --><p>Initialize the system for level set function. A level set function is defined on a coarser mesh than the structural mesh. A level set function is assumed to be a first-order Lagrange finite element</p>
<div class="fragment"><div class="line">_level_set_fetype      = libMesh::FEType(libMesh::FIRST, libMesh::LAGRANGE);</div><div class="line">_level_set_eq_sys      = <span class="keyword">new</span> libMesh::EquationSystems(*_level_set_mesh);</div><div class="line">_level_set_sys         = &amp;(_level_set_eq_sys-&gt;add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;level_set&quot;</span>));</div><div class="line">_level_set_sys-&gt;extra_quadrature_order = 2;</div><div class="line">_level_set_sys_init    = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_system_initialization.html">MAST::LevelSetSystemInitialization</a>(*_level_set_sys,</div><div class="line">                                                                _level_set_sys-&gt;name(),</div><div class="line">                                                                _level_set_fetype);</div><div class="line">_level_set_discipline  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_discipline.html">MAST::LevelSetDiscipline</a>(*_eq_sys);</div></div><!-- fragment --><p>A system with level set function is defined on the strucutral mesh for the purpose of plotting.</p>
<div class="fragment"><div class="line">_level_set_sys_on_str_mesh      = &amp;(_eq_sys-&gt;add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;level_set&quot;</span>));</div><div class="line">_level_set_sys_init_on_str_mesh = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_system_initialization.html">MAST::LevelSetSystemInitialization</a>(*_level_set_sys_on_str_mesh,</div><div class="line">                                                                         _level_set_sys-&gt;name(),</div><div class="line">                                                                         _level_set_fetype);</div></div><!-- fragment --><p>an indicator function is used to locate unconnected free-floating domains of material. The indicator function solves a heat condution problem. Regions with uniformly zero temperature are marked as unconnected domains.</p>
<div class="fragment"><div class="line">    _indicator_sys                  = &amp;(_eq_sys-&gt;add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;indicator&quot;</span>));</div><div class="line">    _indicator_sys_init             = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_heat_conduction_system_initialization.html">MAST::HeatConductionSystemInitialization</a>(*_indicator_sys,</div><div class="line">                                                                                   _indicator_sys-&gt;name(),</div><div class="line">                                                                                   _fetype);</div><div class="line">    _indicator_discipline           = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>(*_eq_sys);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_eq_sys() {</div><div class="line">    </div><div class="line">    _eq_sys-&gt;init();</div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a033caf367f2948d3f44e0d7e3ad1387e">eigen_solver</a>-&gt;set_position_of_spectrum(libMesh::LARGEST_MAGNITUDE);</div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#af33c95057746da93d4a5f65ffe02ec0f">set_exchange_A_and_B</a>(<span class="keyword">true</span>);</div><div class="line">    </div><div class="line">    _level_set_eq_sys-&gt;init();</div><div class="line">}</div></div><!-- fragment --><p>variables added to the mesh</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_fetype() {</div></div><!-- fragment --><p> FEType to initialize the system. Get the order and type of element. </p><div class="fragment"><div class="line">    std::string</div><div class="line">    order_str   = _input(<span class="stringliteral">&quot;fe_order&quot;</span>, <span class="stringliteral">&quot;order of finite element shape basis functions&quot;</span>,    <span class="stringliteral">&quot;first&quot;</span>),</div><div class="line">    family_str  = _input(<span class="stringliteral">&quot;fe_family&quot;</span>,      <span class="stringliteral">&quot;family of finite element shape functions&quot;</span>, <span class="stringliteral">&quot;lagrange&quot;</span>);</div><div class="line">    </div><div class="line">    libMesh::Order</div><div class="line">    o  = libMesh::Utility::string_to_enum&lt;libMesh::Order&gt;(order_str);</div><div class="line">    libMesh::FEFamily</div><div class="line">    fe = libMesh::Utility::string_to_enum&lt;libMesh::FEFamily&gt;(family_str);</div><div class="line">    _fetype = libMesh::FEType(o, fe);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_dirichlet"></a>
Dirichlet Constraints</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_truss();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_inplane_dirichlet"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_inplane() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">*dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(1, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">_discipline-&gt;add_dirichlet_bc(1,  *dirichlet);</div><div class="line"></div><div class="line">dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(3, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">_discipline-&gt;add_dirichlet_bc(3,  *dirichlet);</div><div class="line"></div><div class="line">_discipline-&gt;init_system_dirichlet_bc(*_sys);</div></div><!-- fragment --><p>initialize Dirichlet conditions for indicator system</p>
<div class="fragment"><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(1, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(1,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line">    </div><div class="line">    dirichlet   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(3, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(3,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line"></div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a3e36617407739da87126767cb4af09f9">init_system_dirichlet_bc</a>(*_indicator_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_truss_dirichlet"></a>
Truss</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_truss() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    dirichlet_length_fraction = _input(<span class="stringliteral">&quot;truss_dirichlet_length_fraction&quot;</span>, <span class="stringliteral">&quot;length fraction of the truss boundary where dirichlet condition is applied&quot;</span>, 0.05);</div></div><!-- fragment --><p> identify the boundaries for dirichlet condition </p><div class="fragment"><div class="line">libMesh::MeshBase::const_element_iterator</div><div class="line">e_it   = _mesh-&gt;elements_begin(),</div><div class="line">e_end  = _mesh-&gt;elements_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; e_it != e_end; e_it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Elem* e = *e_it;</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((*e-&gt;node_ptr(0))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">        e-&gt;centroid()(0) &lt;= _length*dirichlet_length_fraction)</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 6);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*e-&gt;node_ptr(1))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">             e-&gt;centroid()(0) &gt;= _length*(1.-dirichlet_length_fraction))</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 7);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((*e-&gt;node_ptr(0))(0) &lt; 1.e-8 &amp;&amp;</div><div class="line">        (*e-&gt;node_ptr(0))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">        e-&gt;centroid()(0) &lt;= _length*dirichlet_length_fraction)</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 8);</div><div class="line">}</div><div class="line"></div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(6) = <span class="stringliteral">&quot;left_dirichlet&quot;</span>;</div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(7) = <span class="stringliteral">&quot;right_dirichlet&quot;</span>;</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; vars = {1, 2, 3, 4, 5};</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">*dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left support</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(6, vars);</div><div class="line">_discipline-&gt;add_dirichlet_bc(6,  *dirichlet);</div><div class="line"></div><div class="line">dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right support</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(7, vars);</div><div class="line">_discipline-&gt;add_dirichlet_bc(7,  *dirichlet);</div><div class="line"></div><div class="line">vars = {0};</div><div class="line">dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left support</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(8, vars);</div><div class="line">_discipline-&gt;add_dirichlet_bc(8,  *dirichlet);</div><div class="line"></div><div class="line">_discipline-&gt;init_system_dirichlet_bc(*_sys);</div></div><!-- fragment --><p>initialize Dirichlet conditions for indicator system</p>
<div class="fragment"><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(6, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(6,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line">    </div><div class="line">    dirichlet   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(7, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(7,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line">    </div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a3e36617407739da87126767cb4af09f9">init_system_dirichlet_bc</a>(*_indicator_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_bracket_dirichlet"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_bracket() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">*dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// bottom boundary</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">_discipline-&gt;add_dirichlet_bc(0,  *dirichlet);</div><div class="line"></div><div class="line">_discipline-&gt;init_system_dirichlet_bc(*_sys);</div></div><!-- fragment --><p>initialize Dirichlet conditions for indicator system</p>
<div class="fragment"><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// bottom boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(0,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line">    </div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a3e36617407739da87126767cb4af09f9">init_system_dirichlet_bc</a>(*_indicator_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_eyebar_dirichlet"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_eye_bar() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">*dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">_discipline-&gt;add_dirichlet_bc(0,  *dirichlet);</div><div class="line"></div><div class="line">_discipline-&gt;init_system_dirichlet_bc(*_sys);</div></div><!-- fragment --><p>initialize Dirichlet conditions for indicator system</p>
<div class="fragment"><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _indicator_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#af0b4df38f1d01ceb173ba58da2112ba0">add_dirichlet_bc</a>(0,  *dirichlet);</div><div class="line">    _boundary_conditions.insert(dirichlet);</div><div class="line">    </div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a3e36617407739da87126767cb4af09f9">init_system_dirichlet_bc</a>(*_indicator_sys);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_loading"></a>
Loading</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_loads() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_loads_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_loads_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_loads_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="ex_5_inplane_loading"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>FluxLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FluxLoad(<span class="keyword">const</span> std::string&amp; nm, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> p, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l1, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> fraction):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(nm), _p(p), _l1(l1), _frac(fraction) { }</div><div class="line">    <span class="keyword">virtual</span> ~FluxLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (fabs(p(0)-_l1*0.5) &lt;= 0.5*_frac*_l1) v = _p;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> _p, _l1, _frac;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_inplane() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    frac    = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">    p_val   =  _input(<span class="stringliteral">&quot;pressure&quot;</span>, <span class="stringliteral">&quot;pressure on side of domain&quot;</span>,   2.e4);</div><div class="line">    </div><div class="line">    FluxLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> FluxLoad( <span class="stringliteral">&quot;pressure&quot;</span>, p_val, _length, frac),</div><div class="line">    *flux_f          = <span class="keyword">new</span> FluxLoad(<span class="stringliteral">&quot;heat_flux&quot;</span>, -2.e6, _length, frac);</div></div><!-- fragment --><p> initialize the load </p><div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>),</div><div class="line">    *f_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14adabe72f5c8920e042481dc015958f373">MAST::HEAT_FLUX</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(2, *p_load);</div><div class="line">    </div><div class="line">    f_load-&gt;add(*flux_f);</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a267ace92e7e60602d40ad3e2adf12ceb">add_side_load</a>(2, *f_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">    _field_functions.insert(flux_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_bracket_loading"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>BracketLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BracketLoad(<span class="keyword">const</span> std::string&amp; nm, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> p, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l1, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> fraction):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(nm), _p(p), _l1(l1), _frac(fraction) { }</div><div class="line">    <span class="keyword">virtual</span> ~BracketLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (fabs(p(0) &gt;= _l1*(1.-_frac))) v = _p;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> _p, _l1, _frac;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_bracket() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    length  = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">    frac    = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.125),</div><div class="line">    p_val   = _input(<span class="stringliteral">&quot;pressure&quot;</span>, <span class="stringliteral">&quot;pressure on side of domain&quot;</span>,   5.e7);</div><div class="line">    </div><div class="line">    BracketLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> BracketLoad( <span class="stringliteral">&quot;pressure&quot;</span>, p_val, length, frac),</div><div class="line">    *flux_f          = <span class="keyword">new</span> BracketLoad(<span class="stringliteral">&quot;heat_flux&quot;</span>, -2.e6, length, frac);</div></div><!-- fragment --><p>initialize the load</p>
<div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>),</div><div class="line">    *f_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14adabe72f5c8920e042481dc015958f373">MAST::HEAT_FLUX</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(5, *p_load);</div><div class="line">    </div><div class="line">    f_load-&gt;add(*flux_f);</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a267ace92e7e60602d40ad3e2adf12ceb">add_side_load</a>(5, *f_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">    _field_functions.insert(flux_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_eyebar_loading"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>EyebarLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    EyebarLoad():</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(<span class="stringliteral">&quot;pressure&quot;</span>) { }</div><div class="line">    <span class="keyword">virtual</span> ~EyebarLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (p(0) &lt;= 0.) v = (-std::pow(p(1), 2) + std::pow(1.5, 2))*1.e6;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_eye_bar() {</div><div class="line">    </div><div class="line">    EyebarLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> EyebarLoad();</div></div><!-- fragment --><p> initialize the load </p><div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(5, *p_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_properties"></a>
Properties</h1>
<h2><a class="anchor" id="ex_5_material_properties"></a>
Material Properties</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_material() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    Eval      = _input(<span class="stringliteral">&quot;E&quot;</span>, <span class="stringliteral">&quot;modulus of elasticity&quot;</span>, 72.e9),</div><div class="line">    rhoval    = _input(<span class="stringliteral">&quot;rho&quot;</span>, <span class="stringliteral">&quot;material density&quot;</span>, 2700.),</div><div class="line">    nu_val    = _input(<span class="stringliteral">&quot;nu&quot;</span>, <span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>,  0.33),</div><div class="line">    kappa_val = _input(<span class="stringliteral">&quot;kappa&quot;</span>, <span class="stringliteral">&quot;shear correction factor&quot;</span>,  5./6.),</div><div class="line">    kval      = _input(<span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;thermal conductivity&quot;</span>,  1.e-2),</div><div class="line">    cpval     = _input(<span class="stringliteral">&quot;cp&quot;</span>, <span class="stringliteral">&quot;thermal capacitance&quot;</span>,  864.);</div><div class="line">    </div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a></div><div class="line">    *E         = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;E&quot;</span>,          Eval),</div><div class="line">    *rho       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;rho&quot;</span>,      rhoval),</div><div class="line">    *nu        = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;nu&quot;</span>,       nu_val),</div><div class="line">    *kappa     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;kappa&quot;</span>, kappa_val),</div><div class="line">    *k         = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;k&quot;</span>,          kval),</div><div class="line">    *cp        = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;cp&quot;</span>,        cpval);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a></div><div class="line">    *E_f     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(    <span class="stringliteral">&quot;E&quot;</span>,      *E),</div><div class="line">    *rho_f   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(  <span class="stringliteral">&quot;rho&quot;</span>,    *rho),</div><div class="line">    *nu_f    = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(   <span class="stringliteral">&quot;nu&quot;</span>,     *nu),</div><div class="line">    *kappa_f = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;kappa&quot;</span>,  *kappa),</div><div class="line">    *k_f     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>( <span class="stringliteral">&quot;k_th&quot;</span>,      *k),</div><div class="line">    *cp_f    = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(   <span class="stringliteral">&quot;cp&quot;</span>,     *cp);</div><div class="line">    </div><div class="line">    _parameters[    E-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a673e80573ae59d74969d601b227545d1">name</a>()]     = E;</div><div class="line">    _parameters[  rho-&gt;name()]     = rho;</div><div class="line">    _parameters[   nu-&gt;name()]     = nu;</div><div class="line">    _parameters[kappa-&gt;name()]     = kappa;</div><div class="line">    _parameters[    k-&gt;name()]     = k;</div><div class="line">    _parameters[   cp-&gt;name()]     = cp;</div><div class="line">    _field_functions.insert(E_f);</div><div class="line">    _field_functions.insert(rho_f);</div><div class="line">    _field_functions.insert(nu_f);</div><div class="line">    _field_functions.insert(kappa_f);</div><div class="line">    _field_functions.insert(k_f);</div><div class="line">    _field_functions.insert(cp_f);</div><div class="line"></div><div class="line">    _m_card = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_isotropic_material_property_card.html">MAST::IsotropicMaterialPropertyCard</a>;</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*E_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*rho_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*nu_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*kappa_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*k_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*cp_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_section_properties"></a>
Section Properties</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_section_property(){</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    th_v      =  _input(<span class="stringliteral">&quot;th&quot;</span>, <span class="stringliteral">&quot;thickness of 2D element&quot;</span>,  0.001);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a></div><div class="line">    *th       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;th&quot;</span>, th_v),</div><div class="line">    *zero     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;zero&quot;</span>, 0.);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a></div><div class="line">    *th_f     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;h&quot;</span>,       *th),</div><div class="line">    *hoff_f   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;off&quot;</span>,   *zero);</div><div class="line">    </div><div class="line">    </div><div class="line">    _parameters[th-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a673e80573ae59d74969d601b227545d1">name</a>()]    = th;</div><div class="line">    _parameters[zero-&gt;name()]  = zero;</div><div class="line">    _field_functions.insert(th_f);</div><div class="line">    _field_functions.insert(hoff_f);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a></div><div class="line">    *p_card   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a>;</div><div class="line">    </div><div class="line">    _p_card   = p_card;</div></div><!-- fragment --><p> set nonlinear strain if requested </p><div class="fragment"><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    nonlinear = _input(<span class="stringliteral">&quot;if_nonlinear&quot;</span>, <span class="stringliteral">&quot;flag to turn on/off nonlinear strain&quot;</span>, <span class="keyword">false</span>);</div><div class="line">    <span class="keywordflow">if</span> (nonlinear) p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_element_property_card_base.html#a80330fb382ca84dc060eeb7ca6b784c6">set_strain</a>(<a class="code" href="namespace_m_a_s_t.html#af0d815f953a3c27690fda4e2748b357daca95d2120f66aa88bd88a58f0d76c4ed">MAST::NONLINEAR_STRAIN</a>);</div><div class="line">    </div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*th_f);</div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*hoff_f);</div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html#a902ba3f2c2a23289a7c394ccb8cc8162">set_material</a>(*_m_card);</div><div class="line">    _discipline-&gt;set_property_for_subdomain(0, *p_card);</div><div class="line">    _indicator_discipline-&gt;<a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html#a184cca5f052ea4d333f57295d1b1ec78">set_property_for_subdomain</a>(0, *p_card);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_initial_solution"></a>
Initial Level Set</h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>Phi:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;RealVectorX&gt; {</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Phi(<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> x0,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> y0,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l1,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l2,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> nx_mesh,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> ny_mesh,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> nx_holes,</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> ny_holes):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#abc8ad2bc4221d7400e5306159e28e588">RealVectorX</a>&gt;(<span class="stringliteral">&quot;Phi&quot;</span>),</div><div class="line">    _x0  (x0),</div><div class="line">    _y0  (y0),</div><div class="line">    _l1  (l1),</div><div class="line">    _l2  (l2),</div><div class="line">    _nx_mesh  (nx_mesh),</div><div class="line">    _ny_mesh  (ny_mesh),</div><div class="line">    _nx_holes (nx_holes),</div><div class="line">    _ny_holes (ny_holes),</div><div class="line">    _pi  (acos(-1.)) {</div><div class="line"></div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">        dx = _l1/(1.*_nx_holes);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_nx_holes; i++)</div><div class="line">            _x_axis_hole_locations.insert(_x0+(i+.5)*dx);</div></div><!-- fragment --><p>now, along the y-axis</p>
<div class="fragment"><div class="line">    dx = _l2/(1.*_ny_holes);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_ny_holes; i++)</div><div class="line">        _y_axis_hole_locations.insert(_y0+(i+0.5)*dx);</div><div class="line">}</div><div class="line"><span class="keyword">virtual</span> ~Phi() {}</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> libMesh::Point&amp; p,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t,</div><div class="line">                        <a class="code" href="mast__data__types_8h.html#abc8ad2bc4221d7400e5306159e28e588">RealVectorX</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">    </div><div class="line">    libmesh_assert_less_equal(t, 1);</div><div class="line">    libmesh_assert_equal_to(v.size(), 1);</div></div><!-- fragment --><p>the libMesh solution projection routine for Lagrange elements will query the function value at the nodes. So, we figure out which nodes should have zero values set to them. if there is one hole in any direction, it will be in the center of the domain. If there are more than 1, then two of the holes will be on the boundary and others will fill the interior evenly.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">dx_mesh = _l1/(1.*_nx_holes),</div><div class="line">dy_mesh = _l2/(1.*_ny_holes);</div><div class="line"></div><div class="line">std::set&lt;Real&gt;::const_iterator</div><div class="line">x_it_low = _x_axis_hole_locations.lower_bound(p(0)-dx_mesh),</div><div class="line">y_it_low = _y_axis_hole_locations.lower_bound(p(1)-dy_mesh);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n = 0;</div></div><!-- fragment --><p>see if the x-location needs a hole</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> ( ; x_it_low != _x_axis_hole_locations.end(); x_it_low++) {</div><div class="line">    <span class="keywordflow">if</span> (std::fabs(*x_it_low - p(0)) &lt;= dx_mesh*0.25) {</div><div class="line">        n++;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>now check the y-location</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> ( ; y_it_low != _y_axis_hole_locations.end(); y_it_low++) {</div><div class="line">            <span class="keywordflow">if</span> (std::fabs(*y_it_low - p(1)) &lt;= dy_mesh*0.25) {</div><div class="line">                n++;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (n == 2)</div><div class="line">            v(0) = -1.e0;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            v(0) = 1.e0;</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    _x0,</div><div class="line">    _y0,</div><div class="line">    _l1,</div><div class="line">    _l2,</div><div class="line">    _nx_mesh,</div><div class="line">    _ny_mesh,</div><div class="line">    _nx_holes,</div><div class="line">    _ny_holes,</div><div class="line">    _pi;</div><div class="line">    std::set&lt;Real&gt; _x_axis_hole_locations;</div><div class="line">    std::set&lt;Real&gt; _y_axis_hole_locations;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> initialize_solution() {</div></div><!-- fragment --><p>initialize solution of the level set problem</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    nx_h    = _input(<span class="stringliteral">&quot;initial_level_set_n_holes_in_x&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;number of holes along x-direction for initial level-set field&quot;</span>, 6),</div><div class="line">    ny_h    = _input(<span class="stringliteral">&quot;initial_level_set_n_holes_in_y&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;number of holes along y-direction for initial level-set field&quot;</span>, 6),</div><div class="line">    nx_m    = _input(<span class="stringliteral">&quot;level_set_nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along x-axis&quot;</span>, 10),</div><div class="line">    ny_m    = _input(<span class="stringliteral">&quot;level_set_ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements of level-set mesh along y-axis&quot;</span>, 10);</div><div class="line"></div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eyebar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Phi&gt; phi;</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span> || s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        phi.reset(<span class="keyword">new</span> Phi(0., 0., _length, _height, nx_m, ny_m, nx_h, ny_h));</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        phi.reset(<span class="keyword">new</span> Phi(-0.5*_height, -0.5*_height, _length, _height, nx_m, ny_m, nx_h, ny_h));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">    </div><div class="line">    _level_set_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#a4a583d9bf19db839265dff485a17cb25">initialize_solution</a>(*phi);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_phi_dvs() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_phi_dvs_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_phi_dvs_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_phi_dvs_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    filter_radius          = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line">    _filter                = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>(*_level_set_sys, filter_radius, _dv_dof_ids);</div><div class="line">    libMesh::NumericVector&lt;Real&gt;&amp; vec = _level_set_sys-&gt;add_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line">    vec = *_level_set_sys-&gt;solution;</div><div class="line">    vec.close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_inplane_initial_level_set"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_inplane() {</div></div><!-- fragment --><p>this assumes that level set is defined using lagrange shape functions</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_level_set_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_level_set_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_level_set_sys-&gt;solution-&gt;size());</div><div class="line">_level_set_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the node values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _level_set_mesh-&gt;nodes_begin(),</div><div class="line">end = _level_set_mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_level_set_mesh-&gt;n_nodes());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line">    </div><div class="line">    dof_id                     = n.dof_number(0, 0, 0);</div></div><!-- fragment --><p> only if node is not on the upper edge </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((n(1)+filter_radius &gt;= _height) &amp;&amp;</div><div class="line">    (n(0)-filter_radius &lt;= _length*.5*(1.+frac))   &amp;&amp;</div><div class="line">    (n(0)+filter_radius &gt;= _length*.5*(1.-frac))) {</div></div><!-- fragment --><p> set value at the material points to a small positive number </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                _level_set_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line"></div><div class="line">            std::ostringstream oss;</div><div class="line">            oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">            val  = local_phi[dof_id];</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line"></div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _level_set_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_truss_initial_level_set"></a>
Truss</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_truss() {</div></div><!-- fragment --><p>this assumes that level set is defined using lagrange shape functions</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_level_set_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_level_set_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_level_set_sys-&gt;solution-&gt;size());</div><div class="line">_level_set_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the node values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _level_set_mesh-&gt;nodes_begin(),</div><div class="line">end = _level_set_mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_level_set_mesh-&gt;n_nodes());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line">    </div><div class="line">    dof_id                     = n.dof_number(0, 0, 0);</div></div><!-- fragment --><p> only if node is not on the upper edge </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((n(1)-filter_radius &lt;= 0.) &amp;&amp;</div><div class="line">    (n(0)-filter_radius &lt;= _length*.5*(1.+frac))   &amp;&amp;</div><div class="line">    (n(0)+filter_radius &gt;= _length*.5*(1.-frac))) {</div></div><!-- fragment --><p> set value at the material points to a small positive number </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                _level_set_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            </div><div class="line">            std::ostringstream oss;</div><div class="line">            oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">            val  = local_phi[dof_id];</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line"></div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _level_set_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_bracket_initial_level_set"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_bracket() {</div><div class="line">    </div><div class="line">    libmesh_assert(_initialized);</div></div><!-- fragment --><p>this assumes that level set is defined using lagrange shape functions</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_level_set_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol           = 1.e-12,</div><div class="line">length        = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">height        = _input(<span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3),</div><div class="line">l_frac        = 0.4,<span class="comment">//_input(&quot;length_fraction&quot;, &quot;fraction of length along x-axis that is in the bracket&quot;, 0.4),</span></div><div class="line">h_frac        = 0.4,<span class="comment">//_input( &quot;height_fraction&quot;, &quot;fraction of length along y-axis that is in the bracket&quot;, 0.4),</span></div><div class="line">x_lim         = length * l_frac,</div><div class="line">y_lim         =  height * (1.-h_frac),</div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.125),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_level_set_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_level_set_sys-&gt;solution-&gt;size());</div><div class="line">_level_set_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p>iterate over all the node values</p>
<div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _level_set_mesh-&gt;nodes_begin(),</div><div class="line">end = _level_set_mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_level_set_mesh-&gt;n_nodes());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line">    </div><div class="line">    dof_id                     = n.dof_number(0, 0, 0);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((n(1)-filter_radius) &lt;= y_lim &amp;&amp; (n(0)+filter_radius) &gt;= length*(1.-frac)) {</div></div><!-- fragment --><p>set value at the constrained points to a small positive number material here</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">        dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">        _level_set_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">    val = local_phi[dof_id];</div></div><!-- fragment --><p>on the boundary, set everything to be zero, so that there is always a boundary there that the optimizer can move</p>
<div class="fragment"><div class="line">            <span class="keywordflow">if</span> (n(0) &lt; tol                     ||  <span class="comment">// left boundary</span></div><div class="line">                std::fabs(n(0) - length) &lt; tol ||  <span class="comment">// right boundary</span></div><div class="line">                std::fabs(n(1) - height) &lt; tol ||  <span class="comment">// top boundary</span></div><div class="line">                (n(0) &gt;= x_lim &amp;&amp; n(1) &lt;= y_lim)) {</div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                    dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                    _level_set_sys-&gt;solution-&gt;set(dof_id, -1.0);</div><div class="line">                val = -1.0;</div><div class="line">            }</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line">            </div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _level_set_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_eyebar_initial_level_set"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_eye_bar() {</div><div class="line">    </div><div class="line">    libmesh_assert(_initialized);</div></div><!-- fragment --><p>this assumes that level set is defined using lagrange shape functions</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_level_set_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol           = 1.e-6,</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_level_set_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_level_set_sys-&gt;solution-&gt;size());</div><div class="line">_level_set_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p>iterate over all the node values</p>
<div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _level_set_mesh-&gt;nodes_begin(),</div><div class="line">end = _level_set_mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_level_set_mesh-&gt;n_nodes());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line">    </div><div class="line">    dof_id                     = n.dof_number(0, 0, 0);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (((n.norm() &lt;= 1.5+filter_radius) &amp;&amp; n(0) &lt;= 0.) ||  <span class="comment">// circle</span></div><div class="line">        (std::fabs(n(0)-_height*1.5) &lt; filter_radius &amp;&amp;  <span class="comment">// right edge</span></div><div class="line">         std::fabs(n(1)) &lt;= 1.+filter_radius)) { <span class="comment">// dirichlet constraint</span></div></div><!-- fragment --><p>set value at the constrained points to a small positive number material here</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">            dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">            _level_set_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">    }</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">    val = local_phi[dof_id];</div></div><!-- fragment --><p>on the boundary, set everything to be zero, so that there is always a boundary there that the optimizer can move</p>
<div class="fragment"><div class="line">            <span class="keywordflow">if</span> (std::fabs(n(0)+_height*0.5) &lt; tol    ||  <span class="comment">// left boundary</span></div><div class="line">                std::fabs(n(1)-_height*0.5) &lt; tol    ||  <span class="comment">// top boundary</span></div><div class="line">                std::fabs(n(1)+_height*0.5) &lt; tol    ||  <span class="comment">// bottom boundary</span></div><div class="line">                std::fabs(n(0)-_height*1.5) &lt; tol) {     <span class="comment">// right boundary</span></div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (dof_id &gt;= _level_set_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                    dof_id &lt;  _level_set_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                    _level_set_sys-&gt;solution-&gt;set(dof_id, -1.);</div><div class="line">                val = -1.;</div><div class="line">            }</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line">            </div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _level_set_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_design_variable_init"></a>
Design Variables</h2>
<pre class="fragment">  initializes the design variable vector, called by the 
  optimization interface. 
</pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> init_dvar(std::vector&lt;Real&gt;&amp; x,</div><div class="line">               std::vector&lt;Real&gt;&amp; xmin,</div><div class="line">               std::vector&lt;Real&gt;&amp; xmax) {</div><div class="line">    </div><div class="line">    x.resize(_n_vars);</div><div class="line">    xmin.resize(_n_vars);</div><div class="line">    xmax.resize(_n_vars);</div><div class="line">    </div><div class="line">    std::fill(xmin.begin(), xmin.end(),   -1.e0);</div><div class="line">    std::fill(xmax.begin(), xmax.end(),    1.e0);</div></div><!-- fragment --><p>now, check if the user asked to initialize dvs from a previous file</p>
<div class="fragment"><div class="line">    std::string</div><div class="line">    nm    =  _input(<span class="stringliteral">&quot;restart_optimization_file&quot;</span>, <span class="stringliteral">&quot;filename with optimization history for restart&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (nm.length()) {</div><div class="line">        </div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        iter = _input(<span class="stringliteral">&quot;restart_optimization_iter&quot;</span>, <span class="stringliteral">&quot;restart iteration number from file&quot;</span>, 0);</div><div class="line">        this-&gt;initialize_dv_from_output_file(nm, iter, x);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">            x[i] = (*_dv_params[i].second)();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_5_analysis"></a>
Function Evaluation and Sensitivity</h1>
<h2><a class="anchor" id="ex_5_element_error_metric"></a>
Element Error Metric</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">_compute_element_errors(libMesh::ErrorVector&amp; error) {</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html">MAST::LevelSetIntersection</a> intersection;</div><div class="line">    </div><div class="line">    libMesh::MeshBase::const_element_iterator</div><div class="line">    it  = _mesh-&gt;active_elements_begin(),</div><div class="line">    end = _mesh-&gt;active_elements_end();</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> ( ; it != end; it++) {</div><div class="line">        </div><div class="line">        <span class="keyword">const</span> libMesh::Elem* elem = *it;</div><div class="line">        intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#a6dd6fe1846a029bfb8852b2ab04e55e8">init</a>( *_level_set_function, *elem, _sys-&gt;time,</div><div class="line">                          _mesh-&gt;max_elem_id(),</div><div class="line">                          _mesh-&gt;max_node_id());</div><div class="line">        <span class="keywordflow">if</span> (intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#ac39c92b91b349c9824ee55b2d9e0d4bf">if_intersection_through_elem</a>())</div><div class="line">            error[elem-&gt;id()] = 1.-intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#a4ad24e99460ad2ec62bbacbcf70b472e">get_positive_phi_volume_fraction</a>();</div><div class="line">        intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#ab81e3be821756e20efc210516e3fbf91">clear</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span>ElemFlag: <span class="keyword">public</span> libMesh::MeshRefinement::ElementFlagging {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ElemFlag(libMesh::MeshBase&amp; mesh, <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction&lt;Real&gt;</a>&amp; phi, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_h):</div><div class="line">    _mesh(mesh), _phi(phi), _max_h(max_h) {}</div><div class="line">    <span class="keyword">virtual</span> ~ElemFlag() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> flag_elements () {</div><div class="line">        </div><div class="line">        <a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html">MAST::LevelSetIntersection</a> intersection;</div><div class="line">        </div><div class="line">        libMesh::MeshBase::element_iterator</div><div class="line">        it  = _mesh.active_elements_begin(),</div><div class="line">        end = _mesh.active_elements_end();</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> ( ; it != end; it++) {</div><div class="line">            </div><div class="line">            libMesh::Elem* elem = *it;</div><div class="line">            intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#a6dd6fe1846a029bfb8852b2ab04e55e8">init</a>( _phi, *elem, 0.,</div><div class="line">                              _mesh.max_elem_id(),</div><div class="line">                              _mesh.max_node_id());</div><div class="line">            <span class="keywordflow">if</span> (intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#ac39c92b91b349c9824ee55b2d9e0d4bf">if_intersection_through_elem</a>()) {</div><div class="line">                </div><div class="line">                <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> vol_frac = intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#a4ad24e99460ad2ec62bbacbcf70b472e">get_positive_phi_volume_fraction</a>();</div><div class="line">                <span class="keywordflow">if</span> (vol_frac &lt; 0.5 &amp;&amp; elem-&gt;level() &lt; _max_h)</div><div class="line">                    elem-&gt;set_refinement_flag(libMesh::Elem::REFINE);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vol_frac &gt; 0.90)</div><div class="line">                    elem-&gt;set_refinement_flag(libMesh::Elem::COARSEN);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">                elem-&gt;set_refinement_flag(libMesh::Elem::COARSEN);</div><div class="line">            intersection.<a class="code" href="class_m_a_s_t_1_1_level_set_intersection.html#ab81e3be821756e20efc210516e3fbf91">clear</a>();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    libMesh::MeshBase&amp; _mesh;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction&lt;Real&gt;</a>&amp; _phi;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _max_h;</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_function_evaluation"></a>
Function Evaluation</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> evaluate(<span class="keyword">const</span> std::vector&lt;Real&gt;&amp; dvars,</div><div class="line">              <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; obj,</div><div class="line">              <span class="keywordtype">bool</span> eval_obj_grad,</div><div class="line">              std::vector&lt;Real&gt;&amp; obj_grad,</div><div class="line">              std::vector&lt;Real&gt;&amp; fvals,</div><div class="line">              std::vector&lt;bool&gt;&amp; eval_grads,</div><div class="line">              std::vector&lt;Real&gt;&amp; grads) {</div><div class="line">    </div><div class="line">    libMesh::out &lt;&lt; <span class="stringliteral">&quot;New Evaluation&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> copy DVs to level set function </p><div class="fragment"><div class="line">libMesh::NumericVector&lt;Real&gt;</div><div class="line">&amp;base_phi = _level_set_sys-&gt;get_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">    <span class="keywordflow">if</span> (_dv_params[i].first &gt;= base_phi.first_local_index() &amp;&amp;</div><div class="line">        _dv_params[i].first &lt;  base_phi.last_local_index())</div><div class="line">        base_phi.set(_dv_params[i].first, dvars[i]);</div><div class="line">base_phi.close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(base_phi, *_level_set_sys-&gt;solution);</div><div class="line">_level_set_function-&gt;init(*_level_set_sys_init, *_level_set_sys-&gt;solution);</div><div class="line">_sys-&gt;solution-&gt;zero();</div></div><!-- fragment --> <hr/>
<p> DO NOT zero out the gradient vector, since GCMMA needs it for the * subproblem solution * ********************************************************************* </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html">MAST::LevelSetNonlinearImplicitAssembly</a>                  nonlinear_assembly(<span class="keyword">true</span>);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html">MAST::LevelSetNonlinearImplicitAssembly</a>                  level_set_assembly(<span class="keyword">false</span>);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_eigenproblem_assembly.html">MAST::LevelSetEigenproblemAssembly</a>                       eigen_assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_stress_assembly.html">MAST::LevelSetStressAssembly</a>                             stress_assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_nonlinear_assembly_elem_operations.html">MAST::StructuralNonlinearAssemblyElemOperations</a>          nonlinear_elem_ops;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_heat_conduction_nonlinear_assembly_elem_operations.html">MAST::HeatConductionNonlinearAssemblyElemOperations</a>      conduction_elem_ops;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_modal_eigenproblem_assembly_elem_operations.html">MAST::StructuralModalEigenproblemAssemblyElemOperations</a>  modal_elem_ops;</div></div><!-- fragment --><p>reinitialize the dof constraints before solution of the linear system FIXME: we should be able to clear the constraint object from the system before it goes out of scope, but libMesh::System does not have a clear method. So, we are going to leave it as is, hoping that libMesh::System will not attempt to use it (most likely, we shoudl be ok).</p>
<pre class="fragment">first constrain the indicator function and solve 
</pre><div class="fragment"><div class="line">       SNESConvergedReason r;</div><div class="line">       <span class="comment">/*{</span></div><div class="line"><span class="comment">           libMesh::out &lt;&lt; &quot;Indicator Function&quot; &lt;&lt; std::endl;</span></div><div class="line"><span class="comment">           nonlinear_assembly.set_discipline_and_system(*_indicator_discipline, *_indicator_sys_init);</span></div><div class="line"><span class="comment">           conduction_elem_ops.set_discipline_and_system(*_indicator_discipline, *_indicator_sys_init);</span></div><div class="line"><span class="comment">           nonlinear_assembly.set_level_set_function(*_level_set_function);</span></div><div class="line"><span class="comment">           </span></div><div class="line"><span class="comment">           MAST::LevelSetConstrainDofs constrain(*_indicator_sys_init, *_level_set_function);</span></div><div class="line"><span class="comment">           constrain.constrain_all_negative_indices(true);</span></div><div class="line"><span class="comment">           _indicator_sys-&gt;attach_constraint_object(constrain);</span></div><div class="line"><span class="comment">           _indicator_sys-&gt;reinit_constraints();</span></div><div class="line"><span class="comment">           _indicator_sys-&gt;solve(conduction_elem_ops, nonlinear_assembly);</span></div><div class="line"><span class="comment">           r = dynamic_cast&lt;libMesh::PetscNonlinearSolver&lt;Real&gt;&amp;&gt;</span></div><div class="line"><span class="comment">           (*_indicator_sys-&gt;nonlinear_solver).get_converged_reason();</span></div><div class="line"><span class="comment">           nonlinear_assembly.clear_level_set_function();</span></div><div class="line"><span class="comment">           nonlinear_assembly.clear_discipline_and_system();</span></div><div class="line"><span class="comment">       }</span></div><div class="line"><span class="comment">* </span></div></div><!-- fragment --><p> if the solver diverged due to linear solve, then there is a problem with this geometry and we need to return with a high value set for the constraints </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (r == SNES_DIVERGED_LINEAR_SOLVE) {</div><div class="line">    </div><div class="line">    obj = 1.e10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_ineq; i++)</div><div class="line">        fvals[i] = 1.e10;</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><p>now, use the indicator function to constrain dofs in the structural system</p>
<div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a> indicator(*_indicator_sys_init, <span class="stringliteral">&quot;indicator&quot;</span>);</div><div class="line">indicator.init(*_indicator_sys-&gt;solution);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_indicator_function_constrain_dofs.html">MAST::IndicatorFunctionConstrainDofs</a> constrain(*_sys_init, *_level_set_function, indicator);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_constrain_dofs.html">MAST::LevelSetConstrainDofs</a> constrain(*_sys_init, *_level_set_function);</div><div class="line">_sys-&gt;attach_constraint_object(constrain);</div><div class="line">_sys-&gt;reinit_constraints();</div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aef44ff5f73171cec65d522b4e75a2797">initialize_condensed_dofs</a>(*_discipline);*/</div></div><!-- fragment --><p>first constrain the indicator function and solve</p>
<div class="fragment"><div class="line">nonlinear_assembly.set_discipline_and_system(*_discipline, *_sys_init);</div><div class="line">nonlinear_assembly.set_level_set_function(*_level_set_function, *_filter);</div><div class="line">nonlinear_assembly.set_level_set_velocity_function(*_level_set_vel);</div></div><!-- fragment --><p> nonlinear_assembly.set_indicator_function(indicator); </p><div class="fragment"><div class="line">eigen_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">eigen_assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_eigenproblem_assembly.html#aec856789694b83ab1df956770a105061">set_level_set_function</a>(*_level_set_function);</div><div class="line">eigen_assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_eigenproblem_assembly.html#ad3b11e03dd188249e7eed2d2e5bd9b45">set_level_set_velocity_function</a>(*_level_set_vel);</div><div class="line">stress_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">stress_assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_stress_assembly.html#ac07d59d4f01c502a1b3432f6aa4bf4da">init</a>(*_level_set_function, nonlinear_assembly.if_use_dof_handler()?&amp;nonlinear_assembly.get_dof_handler():<span class="keyword">nullptr</span>);</div><div class="line">level_set_assembly.set_discipline_and_system(*_level_set_discipline, *_level_set_sys_init);</div><div class="line">level_set_assembly.set_level_set_function(*_level_set_function, *_filter);</div><div class="line">level_set_assembly.set_level_set_velocity_function(*_level_set_vel);</div><div class="line">nonlinear_elem_ops.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">modal_elem_ops.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div></div><!-- fragment --><p> nonlinear_assembly.plot_sub_elems(true, false, true); </p><div class="fragment"><div class="line">libMesh::MeshRefinement refine(*_mesh);</div><div class="line"></div><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;before refinement&quot;</span> &lt;&lt; std::endl;</div><div class="line">_mesh-&gt;print_info();</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span></div><div class="line">continue_refining    = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">threshold            = 0.05;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_refinements        = 0,</div><div class="line">max_refinements      = _input(<span class="stringliteral">&quot;max_refinements&quot;</span>,<span class="stringliteral">&quot;maximum refinements&quot;</span>, 3);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (n_refinements &lt; max_refinements &amp;&amp; continue_refining) {</div></div><!-- fragment --><p> The ErrorVector is a particular StatisticsVector for computing error information on a finite element mesh. </p><div class="fragment"><div class="line">    libMesh::ErrorVector error(_mesh-&gt;max_elem_id(), _mesh);</div><div class="line">    _compute_element_errors(error);</div><div class="line">    libMesh::out</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;After refinement: &quot;</span> &lt;&lt; n_refinements &lt;&lt; std::endl</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;max error:    &quot;</span> &lt;&lt; error.maximum()</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;,  mean error: &quot;</span> &lt;&lt; error.mean() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (error.maximum() &gt; threshold) {</div><div class="line">        </div><div class="line">        ElemFlag flag(*_mesh, *_level_set_function, max_refinements);</div><div class="line">        refine.max_h_level()      = max_refinements;</div><div class="line">        refine.refine_fraction()  = 1.;</div><div class="line">        refine.coarsen_fraction() = 0.5;</div><div class="line">        refine.flag_elements_by (flag);</div><div class="line">        <span class="keywordflow">if</span> (refine.refine_and_coarsen_elements())</div><div class="line">            _eq_sys-&gt;reinit ();</div><div class="line"></div><div class="line">        _mesh-&gt;print_info();</div><div class="line">        </div><div class="line">        n_refinements++;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        continue_refining = <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_volume.html">MAST::LevelSetVolume</a>                            volume(level_set_assembly.get_intersection());</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_level_set_perimeter.html">MAST::LevelSetPerimeter</a>                         perimeter(level_set_assembly.get_intersection());</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html">MAST::StressStrainOutputBase</a>                    stress;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_compliance_output.html">MAST::ComplianceOutput</a>                          compliance;</div><div class="line">volume.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_level_set_discipline, *_level_set_sys_init);</div><div class="line">perimeter.set_discipline_and_system(*_level_set_discipline, *_level_set_sys_init);</div><div class="line">stress.set_discipline_and_system(*_discipline, *_sys_init);</div><div class="line">volume.set_participating_elements_to_all();</div><div class="line">perimeter.set_participating_elements_to_all();</div><div class="line">stress.set_participating_elements_to_all();</div><div class="line">stress.set_aggregation_coefficients(_p_val, 1., _vm_rho, _stress_lim) ;</div><div class="line">compliance.<a class="code" href="class_m_a_s_t_1_1_output_assembly_elem_operations.html#ad7ce0a9393f174a5d19a52e6736ae988">set_participating_elements_to_all</a>();</div><div class="line">compliance.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div></div><!-- fragment --><p>evaluate the stress constraint</p>
<p>tell the thermal jacobian scaling object about the assembly object </p><div class="fragment"><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;Static Solve&quot;</span> &lt;&lt; std::endl;</div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aaaed1f33d18591f0f380516e1e2fbb8c">solve</a>(nonlinear_elem_ops, nonlinear_assembly);</div><div class="line">r = <span class="keyword">dynamic_cast&lt;</span>libMesh::PetscNonlinearSolver&lt;Real&gt;&amp;<span class="keyword">&gt;</span></div><div class="line">(*_sys-&gt;nonlinear_solver).get_converged_reason();</div></div><!-- fragment --><p> if the solver diverged due to linear solve, then there is a problem with this geometry and we need to return with a high value set for the constraints </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (r == SNES_DIVERGED_LINEAR_SOLVE ||</div><div class="line">    _sys-&gt;final_nonlinear_residual() &gt; 1.e-1) {</div><div class="line">    </div><div class="line">    obj = 1.e10;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_ineq; i++)</div><div class="line">        fvals[i] = 1.e10;</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line">nonlinear_assembly.calculate_output(*_sys-&gt;solution, stress);</div></div><!-- fragment --><p> nonlinear_assembly.calculate_output(*_sys-&gt;solution, compliance); </p><div class="fragment"></div><!-- fragment --><p>evaluate the objective</p>
<div class="fragment"><div class="line">level_set_assembly.set_evaluate_output_on_negative_phi(<span class="keyword">false</span>);</div><div class="line">level_set_assembly.calculate_output(*_level_set_sys-&gt;solution, volume);</div><div class="line">level_set_assembly.set_evaluate_output_on_negative_phi(<span class="keyword">true</span>);</div><div class="line">level_set_assembly.calculate_output(*_level_set_sys-&gt;solution, perimeter);</div><div class="line">level_set_assembly.set_evaluate_output_on_negative_phi(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">max_vm = stress.get_maximum_von_mises_stress(),</div><div class="line">vm_agg = stress.output_total(),</div><div class="line">vf     = _input(<span class="stringliteral">&quot;volume_fraction&quot;</span>, <span class="stringliteral">&quot;volume fraction&quot;</span>, 0.3),</div><div class="line">vol    = volume.output_total(),</div><div class="line">per    = perimeter.output_total(),</div><div class="line">comp   = compliance.<a class="code" href="class_m_a_s_t_1_1_compliance_output.html#aea42a279b0c213fa4a98a5f098c302b4">output_total</a>();</div><div class="line"></div><div class="line">obj       = _obj_scaling * (vol + _perimeter_penalty * per);</div></div><!-- fragment --><p> _obj_scaling * (vol+ _perimeter_penalty * per) + _stress_penalty * (vm_agg);///_stress_lim - 1.); </p><div class="fragment"><div class="line">fvals[0]  =  stress.output_total()/_stress_lim - 1.;  <span class="comment">// g = sigma/sigma0-1 &lt;= 0</span></div></div><!-- fragment --><p> fvals[0] = stress.output_total()/_length/_height; // g &lt;= 0 for the smooth ramp function fvals[0] = vol/_length/_height - vf; // vol/vol0 - a &lt;= </p><div class="fragment"><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;volume: &quot;</span> &lt;&lt; vol    &lt;&lt; <span class="stringliteral">&quot;  perim: &quot;</span>  &lt;&lt; per    &lt;&lt; std::endl;</div><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;max: &quot;</span>    &lt;&lt; max_vm &lt;&lt; <span class="stringliteral">&quot;  constr: &quot;</span> &lt;&lt; vm_agg/_stress_lim - 1.</div><div class="line">&lt;&lt; std::endl;</div><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;compliance: &quot;</span> &lt;&lt; comp &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (_n_eig_vals) {</div></div><!-- fragment --><p>evaluate the eigenvalue constraint</p>
<div class="fragment"><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;Eigen Solve&quot;</span> &lt;&lt; std::endl;</div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a2986ba3e2b32c728c79c278204f2e468">eigenproblem_solve</a>(modal_elem_ops, eigen_assembly);</div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> eig_imag = 0.;</div></div><!-- fragment --><p>hopefully, the solver found the requested number of eigenvalues. if not, then we will set zero values for the ones it did not.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_conv = std::min(_n_eig_vals, _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#ab7060976615d42252dd36557967d98fa">get_n_converged_eigenvalues</a>());</div><div class="line">std::vector&lt;Real&gt; eig(_n_eig_vals, 0.);</div></div><!-- fragment --><p> get the converged eigenvalues </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_conv; i++)      _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a4fd5b5cc514f19b7a693c28a31fcf56c">get_eigenvalue</a>(0, eig[i], eig_imag);</div></div><!-- fragment --><p>eig &gt; eig0 -eig &lt; -eig0 -eig/eig0 &lt; -1 -eig/eig0 + 1 &lt; 0</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_eig_vals; i++)</div><div class="line">        fvals[i+1] = -eig[i]/_ref_eig_val + 1.;</div><div class="line">}</div></div><!-- fragment --><p>evaluate the objective sensitivities, if requested</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (eval_obj_grad) {</div><div class="line">    </div><div class="line">    std::vector&lt;Real&gt;</div><div class="line">    grad1(obj_grad.size(), 0.);</div><div class="line">    </div><div class="line">    _evaluate_volume_sensitivity(&amp;volume, &amp;perimeter, level_set_assembly, obj_grad);</div><div class="line">    </div><div class="line">    <span class="comment">/*_evaluate_compliance_sensitivity(compliance,</span></div><div class="line"><span class="comment">                                     nonlinear_elem_ops,</span></div><div class="line"><span class="comment">                                     nonlinear_assembly,</span></div><div class="line"><span class="comment">                                     grad1);</span></div><div class="line"><span class="comment">    </span></div><div class="line"><span class="comment">    for (unsigned int i=0; i&lt;obj_grad.size(); i++)</span></div><div class="line"><span class="comment">        obj_grad[i] += _obj_scaling * grad1[i];*/</span></div><div class="line">}</div></div><!-- fragment --><p>check to see if the sensitivity of constraint is requested</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> if_grad_sens = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;eval_grads.size(); i++)</div><div class="line">    if_grad_sens = (if_grad_sens || eval_grads[i]);</div></div><!-- fragment --><p>evaluate the sensitivities for constraints</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (if_grad_sens)</div><div class="line">    _evaluate_stress_sensitivity(stress,</div><div class="line">                                 nonlinear_elem_ops,</div><div class="line">                                 nonlinear_assembly,</div><div class="line">                                 modal_elem_ops,</div><div class="line">                                 eigen_assembly,</div><div class="line">                                 grads);</div></div><!-- fragment --><p> _evaluate_volume_sensitivity(&amp;volume, nullptr, level_set_assembly, grads); </p><div class="fragment"></div><!-- fragment --><p>also the stress data for plotting</p>
<div class="fragment"><div class="line">    stress_assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_stress_assembly.html#ac4064fc6d241fb71ca3d6dd9b467f818">update_stress_strain_data</a>(stress, *_sys-&gt;solution);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_volume_sensitivity"></a>
Sensitivity of Material Volume</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _evaluate_volume_sensitivity(<a class="code" href="class_m_a_s_t_1_1_level_set_volume.html">MAST::LevelSetVolume</a>*    volume,</div><div class="line">                                  <a class="code" href="class_m_a_s_t_1_1_level_set_perimeter.html">MAST::LevelSetPerimeter</a>* perimeter,</div><div class="line">                                  <a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html">MAST::LevelSetNonlinearImplicitAssembly</a>&amp; assembly,</div><div class="line">                                  std::vector&lt;Real&gt;&amp; grad) {</div><div class="line">    </div><div class="line">    std::fill(grad.begin(), grad.end(), 0.);</div></div><!-- fragment --><p>iterate over each DV, create a sensitivity vector and calculate the volume sensitivity explicitly</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">dphi_base(_level_set_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">dphi_filtered(_level_set_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line"></div><div class="line">ElementParameterDependence dep(*_filter);</div><div class="line">assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a7a236e900be0ba6dbfe630ebb51e3152">attach_elem_parameter_dependence_object</a>(dep);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div><div class="line"></div><div class="line">_level_set_vel-&gt;<a class="code" href="class_m_a_s_t_1_1_level_set_boundary_velocity.html#a21a9941eb0d122434ad8ade53ad444a3">init</a>(*_level_set_sys_init, *_level_set_sys-&gt;solution, *dphi_filtered);</div></div><!-- fragment --><p> if the volume output was specified then compute the sensitivity and add to the grad vector </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (volume) {</div><div class="line">    </div><div class="line">    assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html#a2fe017d0d95bf0182d806a1a5ca16717">set_evaluate_output_on_negative_phi</a>(<span class="keyword">false</span>);</div><div class="line">    assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html#ad6fedc5dc5eba971c4e604298d0982f7">calculate_output_direct_sensitivity</a>(*_level_set_sys-&gt;solution,</div><div class="line">                                                 dphi_filtered.get(),</div><div class="line">                                                 *_dv_params[i].second,</div><div class="line">                                                 *volume);</div><div class="line">    </div><div class="line">    grad[i] = _obj_scaling * volume-&gt;<a class="code" href="class_m_a_s_t_1_1_level_set_volume.html#a4d29861077f45e2bdc9e4ecfab978f49">output_sensitivity_total</a>(*_dv_params[i].second);</div></div><!-- fragment --><p> grad[i] = volume-&gt;output_sensitivity_total(*_dv_params[i].second)/_length/_height; </p><div class="fragment"><div class="line">}</div></div><!-- fragment --><p> if the perimeter output was specified then compute the sensitivity and add to the grad vector </p><div class="fragment"><div class="line">        <span class="keywordflow">if</span> (perimeter) {</div><div class="line">            assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html#a2fe017d0d95bf0182d806a1a5ca16717">set_evaluate_output_on_negative_phi</a>(<span class="keyword">true</span>);</div><div class="line">            assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html#ad6fedc5dc5eba971c4e604298d0982f7">calculate_output_direct_sensitivity</a>(*_level_set_sys-&gt;solution,</div><div class="line">                                                         dphi_filtered.get(),</div><div class="line">                                                         *_dv_params[i].second,</div><div class="line">                                                         *perimeter);</div><div class="line">            assembly.<a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html#a2fe017d0d95bf0182d806a1a5ca16717">set_evaluate_output_on_negative_phi</a>(<span class="keyword">false</span>);</div><div class="line">            </div><div class="line">            grad[i] += _obj_scaling * _perimeter_penalty *</div><div class="line">            perimeter-&gt;<a class="code" href="class_m_a_s_t_1_1_level_set_perimeter.html#a2180171bda6a37c1327a5c2fe288edcd">output_sensitivity_total</a>(*_dv_params[i].second);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#af8281c5eece58746b64293f8ccea49f3">clear_elem_parameter_dependence_object</a>();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_stress_sensitivity"></a>
Sensitivity of Stress and Eigenvalues</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">_evaluate_stress_sensitivity</div><div class="line">(<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html">MAST::StressStrainOutputBase</a>&amp; stress,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html">MAST::AssemblyElemOperations</a>&amp; nonlinear_elem_ops,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html">MAST::LevelSetNonlinearImplicitAssembly</a>&amp; nonlinear_assembly,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_structural_modal_eigenproblem_assembly_elem_operations.html">MAST::StructuralModalEigenproblemAssemblyElemOperations</a>&amp; eigen_elem_ops,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_level_set_eigenproblem_assembly.html">MAST::LevelSetEigenproblemAssembly</a>&amp; eigen_assembly,</div><div class="line"> std::vector&lt;Real&gt;&amp; grads) {</div><div class="line">    </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_conv = std::min(_n_eig_vals, _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#ab7060976615d42252dd36557967d98fa">get_n_converged_eigenvalues</a>());</div><div class="line">    </div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a2eb7bf075f1c1e1f433963cc2dca5058">adjoint_solve</a>(nonlinear_elem_ops, stress, nonlinear_assembly, <span class="keyword">false</span>);</div><div class="line">    </div><div class="line">    std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">    dphi_base(_level_set_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">    dphi_filtered(_level_set_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line"></div><div class="line">    ElementParameterDependence dep(*_filter);</div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a7a236e900be0ba6dbfe630ebb51e3152">attach_elem_parameter_dependence_object</a>(dep);</div></div><!-- fragment --><p>indices used by GCMMA follow this rule: grad_k = dfi/dxj , where k = j*NFunc + i</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div></div><!-- fragment --><p>initialize the level set perturbation function to create a velocity field </p><div class="fragment"><div class="line">_level_set_vel-&gt;<a class="code" href="class_m_a_s_t_1_1_level_set_boundary_velocity.html#a21a9941eb0d122434ad8ade53ad444a3">init</a>(*_level_set_sys_init, *_level_set_sys-&gt;solution, *dphi_filtered);</div></div><!-- fragment --><p>stress sensitivity</p>
<div class="fragment"><div class="line">grads[1*i+0] = 1./_stress_lim*</div><div class="line">nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#ab6d7c383e893dca4de61657ee7f042cf">calculate_output_adjoint_sensitivity</a>(*_sys-&gt;solution,</div><div class="line">                                                        _sys-&gt;get_adjoint_solution(),</div><div class="line">                                                        *_dv_params[i].second,</div><div class="line">                                                        nonlinear_elem_ops,</div><div class="line">                                                        stress);</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html#a8ff558125b2c542e6c5b3d7de95713cd">clear_sensitivity_data</a>();</div></div><!-- fragment --><p>eigenvalue sensitivity, only if the values were requested</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (_n_eig_vals) {</div><div class="line">            </div><div class="line">            std::vector&lt;Real&gt; sens;</div><div class="line">            _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a967f97f32cb9ccdedebf6bce97071655">eigenproblem_sensitivity_solve</a>(eigen_elem_ops,</div><div class="line">                                                 eigen_assembly,</div><div class="line">                                                 *_dv_params[i].second,</div><div class="line">                                                 sens);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;n_conv; j++)</div><div class="line">                grads[_n_ineq*i+j+1] = -sens[j]/_ref_eig_val;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#af8281c5eece58746b64293f8ccea49f3">clear_elem_parameter_dependence_object</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_evaluate_compliance_sensitivity</div><div class="line">(<a class="code" href="class_m_a_s_t_1_1_compliance_output.html">MAST::ComplianceOutput</a>&amp; compliance,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html">MAST::AssemblyElemOperations</a>&amp; nonlinear_elem_ops,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_level_set_nonlinear_implicit_assembly.html">MAST::LevelSetNonlinearImplicitAssembly</a>&amp; nonlinear_assembly,</div><div class="line"> std::vector&lt;Real&gt;&amp; grads) {</div></div><!-- fragment --><p> Adjoint solution for compliance = - X </p><div class="fragment"><div class="line">std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">dphi_base(_level_set_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">dphi_filtered(_level_set_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line"></div><div class="line">ElementParameterDependence dep(*_filter);</div><div class="line">nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a7a236e900be0ba6dbfe630ebb51e3152">attach_elem_parameter_dependence_object</a>(dep);</div></div><!-- fragment --><p>indices used by GCMMA follow this rule: grad_k = dfi/dxj , where k = j*NFunc + i</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div></div><!-- fragment --><p>initialize the level set perturbation function to create a velocity field </p><div class="fragment"><div class="line">_level_set_vel-&gt;<a class="code" href="class_m_a_s_t_1_1_level_set_boundary_velocity.html#a21a9941eb0d122434ad8ade53ad444a3">init</a>(*_level_set_sys_init, *_level_set_sys-&gt;solution, *dphi_filtered);</div></div><!-- fragment --><p>compliance sensitivity</p>
<div class="fragment"><div class="line">        grads[i] = -1. *</div><div class="line">        nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#ab6d7c383e893dca4de61657ee7f042cf">calculate_output_adjoint_sensitivity</a>(*_sys-&gt;solution,</div><div class="line">                                                                *_sys-&gt;solution,</div><div class="line">                                                                *_dv_params[i].second,</div><div class="line">                                                                nonlinear_elem_ops,</div><div class="line">                                                                compliance);</div><div class="line">    }</div><div class="line">    </div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#af8281c5eece58746b64293f8ccea49f3">clear_elem_parameter_dependence_object</a>();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_design_output"></a>
Output of Design Iterate</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> output(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iter,</div><div class="line">            <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; x,</div><div class="line">            <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> obj,</div><div class="line">            <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; fval,</div><div class="line">            <span class="keywordtype">bool</span> if_write_to_optim_file) {</div><div class="line">    </div><div class="line">    libmesh_assert_equal_to(x.size(), _n_vars);</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    sys_time     = _sys-&gt;time;</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    output_name  = _input(<span class="stringliteral">&quot;output_file_root&quot;</span>, <span class="stringliteral">&quot;prefix of output file names&quot;</span>, <span class="stringliteral">&quot;output&quot;</span>),</div><div class="line">    modes_name   = output_name + <span class="stringliteral">&quot;modes.exo&quot;</span>;</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;output_optim.e-s.&quot;</span> &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; std::setw(5) &lt;&lt; iter ;</div></div><!-- fragment --><p>copy DVs to level set function</p>
<div class="fragment"><div class="line">libMesh::NumericVector&lt;Real&gt;</div><div class="line">&amp;base_phi = _level_set_sys-&gt;get_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">    <span class="keywordflow">if</span> (_dv_params[i].first &gt;= base_phi.first_local_index() &amp;&amp;</div><div class="line">        _dv_params[i].first &lt;  base_phi.last_local_index())</div><div class="line">        base_phi.set(_dv_params[i].first, x[i]);</div><div class="line">base_phi.close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(base_phi, *_level_set_sys-&gt;solution);</div><div class="line">_level_set_function-&gt;init(*_level_set_sys_init, *_level_set_sys-&gt;solution);</div><div class="line">_level_set_sys_init_on_str_mesh-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#a4a583d9bf19db839265dff485a17cb25">initialize_solution</a>(_level_set_function-&gt;get_mesh_function());</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; eval_grads(this-&gt;n_ineq(), <span class="keyword">false</span>);</div><div class="line">std::vector&lt;Real&gt; f(this-&gt;n_ineq(), 0.), grads;</div><div class="line">this-&gt;evaluate(x, obj, <span class="keyword">false</span>, grads, f, eval_grads, grads);</div><div class="line"></div><div class="line">_sys-&gt;time = iter;</div><div class="line">_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html#a1a3a8a8871255e3c19560908473658d8">get_stress_sys</a>().time = iter;</div></div><!-- fragment --><p> "1" is the number of time-steps in the file, as opposed to the time-step number. </p><div class="fragment"><div class="line">libMesh::ExodusII_IO(*_mesh).write_timestep(oss.str(), *_eq_sys, 1, (1.*iter));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (_n_eig_vals) {</div></div><!-- fragment --><p>eigenvalue analysis: write modes to file</p>
<div class="fragment"><div class="line">    libMesh::ExodusII_IO writer(*_mesh);</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> eig_r, eig_i;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#ab7060976615d42252dd36557967d98fa">get_n_converged_eigenvalues</a>(); i++) {</div><div class="line">        _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aa67d9d7b6f199f73341296cebbfcfcd2">get_eigenpair</a>(i, eig_r, eig_i, *_sys-&gt;solution);</div><div class="line">        writer.write_timestep(modes_name, *_eq_sys, i+1, i);</div><div class="line">    }</div><div class="line">    _sys-&gt;solution-&gt;zero();</div><div class="line">}</div></div><!-- fragment --><p>set the value of time back to its original value</p>
<div class="fragment"><div class="line">_sys-&gt;time = sys_time;</div></div><!-- fragment --><p>increment the parameter values</p>
<div class="fragment"><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        update_freq = _input(<span class="stringliteral">&quot;update_freq_optim_params&quot;</span>, <span class="stringliteral">&quot;number of iterations after which the optimization parameters are updated&quot;</span>, 50),</div><div class="line">        factor = iter/update_freq ;</div><div class="line">        <span class="keywordflow">if</span> (factor &gt; 0 &amp;&amp; iter%update_freq == 0) {</div><div class="line">            </div><div class="line">            <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">            p_val           = _input(<span class="stringliteral">&quot;constraint_aggregation_p_val&quot;</span>, <span class="stringliteral">&quot;value of p in p-norm stress aggregation&quot;</span>, 2.0),</div><div class="line">            vm_rho          = _input(<span class="stringliteral">&quot;constraint_aggregation_rho_val&quot;</span>, <span class="stringliteral">&quot;value of rho in p-norm stress aggregation&quot;</span>, 2.0),</div><div class="line">            constr_penalty  = _input(<span class="stringliteral">&quot;constraint_penalty&quot;</span>, <span class="stringliteral">&quot;constraint penalty in GCMMA&quot;</span>,      50.),</div><div class="line">            max_penalty     = _input(<span class="stringliteral">&quot;max_constraint_penalty&quot;</span>, <span class="stringliteral">&quot;maximum constraint penalty in GCMMA&quot;</span>,      1.e7),</div><div class="line">            initial_step    = _input(<span class="stringliteral">&quot;initial_rel_step&quot;</span>, <span class="stringliteral">&quot;initial relative step length in GCMMA&quot;</span>,      0.5),</div><div class="line">            min_step        = _input(<span class="stringliteral">&quot;minimum_rel_step&quot;</span>, <span class="stringliteral">&quot;minimum relative step length in GCMMA&quot;</span>,      0.001);</div><div class="line">            </div><div class="line">            constr_penalty = std::min(constr_penalty*pow(10, factor), max_penalty);</div><div class="line">            initial_step   = std::max(initial_step-0.01*factor, min_step);</div><div class="line">            _p_val         = std::min(p_val+2*factor, 10.);</div><div class="line">            _vm_rho        = std::min(vm_rho+factor*0.5, 2.);</div><div class="line">            libMesh::out</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Updated values: c = &quot;</span> &lt;&lt; constr_penalty</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  step = &quot;</span> &lt;&lt; initial_step</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  p = &quot;</span> &lt;&lt; _p_val</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  rho = &quot;</span> &lt;&lt; _vm_rho &lt;&lt; std::endl;</div><div class="line">            </div><div class="line">            _optimization_interface-&gt;set_real_parameter   ( <span class="stringliteral">&quot;constraint_penalty&quot;</span>,   constr_penalty);</div><div class="line">            _optimization_interface-&gt;set_real_parameter   (<span class="stringliteral">&quot;initial_rel_step&quot;</span>,        initial_step);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="class_m_a_s_t_1_1_function_evaluation.html#a8431337afb467479c95dbb0e1b1af4c6">MAST::FunctionEvaluation::output</a>(iter, x, obj/_obj_scaling, f, if_write_to_optim_file);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="preprocessor">#if MAST_ENABLE_SNOPT == 1</span></div><div class="line">    MAST::FunctionEvaluation::funobj</div><div class="line">    get_objective_evaluation_function() {</div><div class="line">    </div><div class="line">        <span class="keywordflow">return</span> _optim_obj;</div><div class="line">    }</div><div class="line"></div><div class="line">    MAST::FunctionEvaluation::funcon</div><div class="line">    get_constraint_evaluation_function() {</div><div class="line">    </div><div class="line">        <span class="keywordflow">return</span> _optim_con;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h1><a class="anchor" id="ex_5_initialization"></a>
Initialization</h1>
<h2><a class="anchor" id="ex_5_constructor"></a>
Constructor</h2>
<div class="fragment"><div class="line">TopologyOptimizationLevelSet2D(<span class="keyword">const</span> libMesh::Parallel::Communicator&amp; comm_in,</div><div class="line">                               MAST::Examples::GetPotWrapper&amp; input):</div><div class="line"><a class="code" href="namespace_m_a_s_t.html">MAST</a>::FunctionEvaluation             (comm_in),</div><div class="line">_initialized                         (false),</div><div class="line">_input                               (input),</div><div class="line">_length                              (0.),</div><div class="line">_height                              (0.),</div><div class="line">_obj_scaling                         (0.),</div><div class="line">_stress_penalty                      (0.),</div><div class="line">_perimeter_penalty                   (0.),</div><div class="line">_stress_lim                          (0.),</div><div class="line">_p_val                               (0.),</div><div class="line">_vm_rho                              (0.),</div><div class="line">_ref_eig_val                         (0.),</div><div class="line">_n_eig_vals                          (0),</div><div class="line">_mesh                                (nullptr),</div><div class="line">_level_set_mesh                      (nullptr),</div><div class="line">_eq_sys                              (nullptr),</div><div class="line">_level_set_eq_sys                    (nullptr),</div><div class="line">_sys                                 (nullptr),</div><div class="line">_level_set_sys                       (nullptr),</div><div class="line">_level_set_sys_on_str_mesh           (nullptr),</div><div class="line">_indicator_sys                       (nullptr),</div><div class="line">_sys_init                            (nullptr),</div><div class="line">_level_set_sys_init_on_str_mesh      (nullptr),</div><div class="line">_level_set_sys_init                  (nullptr),</div><div class="line">_indicator_sys_init                  (nullptr),</div><div class="line">_discipline                          (nullptr),</div><div class="line">_indicator_discipline                (nullptr),</div><div class="line">_level_set_discipline                (nullptr),</div><div class="line">_filter                              (nullptr),</div><div class="line">_m_card                              (nullptr),</div><div class="line">_p_card                              (nullptr),</div><div class="line">_level_set_function                  (nullptr),</div><div class="line">_level_set_vel                       (nullptr),</div><div class="line">_output                              (nullptr) {</div><div class="line">    </div><div class="line">    libmesh_assert(!_initialized);</div></div><!-- fragment --><p>call the initialization routines for each component</p>
<div class="fragment"><div class="line">_init_fetype();</div><div class="line">_init_mesh();</div><div class="line">_init_system_and_discipline();</div><div class="line">_init_dirichlet_conditions();</div><div class="line">_init_eq_sys();</div><div class="line">_init_material();</div><div class="line">_init_loads();</div><div class="line">_init_section_property();</div><div class="line">_initialized = <span class="keyword">true</span>;</div></div><!-- fragment --><p>ask structure to use Mindlin bending operator</p>
<div class="fragment"><div class="line"><span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_m_a_s_t_1_1_element_property_card2_d.html">MAST::ElementPropertyCard2D</a>&amp;<span class="keyword">&gt;</span>(*_p_card).<a class="code" href="class_m_a_s_t_1_1_element_property_card2_d.html#a996d5416432c2e6c5b50b609e5036d50">set_bending_model</a>(<a class="code" href="namespace_m_a_s_t.html#a94a01c803186334c9074965d417ba049a40e284f45a3d0210bcb6dfd933d10e09">MAST::MINDLIN</a>);</div></div><!-- fragment --><p>now initialize the design data.</p>
<div class="fragment"></div><!-- fragment --><p>first, initialize the level set functions over the domain</p>
<div class="fragment"><div class="line">this-&gt;initialize_solution();</div></div><!-- fragment --><p>next, define a new parameter to define design variable for nodal level-set function value</p>
<div class="fragment"><div class="line">this-&gt;_init_phi_dvs();</div><div class="line"></div><div class="line">_obj_scaling           = 1./_length/_height;</div><div class="line">_stress_penalty        = _input(<span class="stringliteral">&quot;stress_penalty&quot;</span>, <span class="stringliteral">&quot;penalty value for stress_constraint&quot;</span>, 0.);</div><div class="line">_perimeter_penalty     = _input(<span class="stringliteral">&quot;perimeter_penalty&quot;</span>, <span class="stringliteral">&quot;penalty value for perimeter in the objective function&quot;</span>, 0.);</div><div class="line">_stress_lim            = _input(<span class="stringliteral">&quot;vm_stress_limit&quot;</span>, <span class="stringliteral">&quot;limit von-mises stress value&quot;</span>, 2.e8);</div><div class="line">_p_val                 = _input(<span class="stringliteral">&quot;constraint_aggregation_p_val&quot;</span>, <span class="stringliteral">&quot;value of p in p-norm stress aggregation&quot;</span>, 2.0);</div><div class="line">_vm_rho                = _input(<span class="stringliteral">&quot;constraint_aggregation_rho_val&quot;</span>, <span class="stringliteral">&quot;value of rho in p-norm stress aggregation&quot;</span>, 2.0);</div><div class="line">_level_set_vel         = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_boundary_velocity.html">MAST::LevelSetBoundaryVelocity</a>(2);</div><div class="line">_level_set_function    = <span class="keyword">new</span> PhiMeshFunction;</div><div class="line">_output                = <span class="keyword">new</span> libMesh::ExodusII_IO(*_mesh);</div><div class="line"></div><div class="line">_n_eig_vals            = _input(<span class="stringliteral">&quot;n_eig&quot;</span>, <span class="stringliteral">&quot;number of eigenvalues to constrain&quot;</span>, 0);</div><div class="line"><span class="keywordflow">if</span> (_n_eig_vals) {</div></div><!-- fragment --><p>set only if the user requested eigenvalue constraints</p>
<div class="fragment"><div class="line">    _ref_eig_val           = _input(<span class="stringliteral">&quot;eigenvalue_low_bound&quot;</span>, <span class="stringliteral">&quot;lower bound enforced on eigenvalue constraints&quot;</span>, 1.e3);</div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a875e777d4051530ad52bc505d1fe9112">set_n_requested_eigenvalues</a>(_n_eig_vals);</div><div class="line">}</div></div><!-- fragment --><p>two inequality constraints: stress and eigenvalue.</p>
<div class="fragment"><div class="line">    _n_ineq = 1+_n_eig_vals;</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    output_name = _input(<span class="stringliteral">&quot;output_file_root&quot;</span>, <span class="stringliteral">&quot;prefix of output file names&quot;</span>, <span class="stringliteral">&quot;output&quot;</span>);</div><div class="line">    output_name += <span class="stringliteral">&quot;_optim_history.txt&quot;</span>;</div><div class="line">    this-&gt;set_output_file(output_name);</div><div class="line">    </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_destructor"></a>
Destructor</h2>
<div class="fragment"><div class="line">    ~TopologyOptimizationLevelSet2D() {</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::set&lt;MAST::BoundaryConditionBase*&gt;::iterator</div><div class="line">            it   = _boundary_conditions.begin(),</div><div class="line">            end  = _boundary_conditions.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> *it;</div><div class="line">        }</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::set&lt;MAST::FunctionBase*&gt;::iterator</div><div class="line">            it   = _field_functions.begin(),</div><div class="line">            end  = _field_functions.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> *it;</div><div class="line">        }</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::map&lt;std::string, MAST::Parameter*&gt;::iterator</div><div class="line">            it   = _parameters.begin(),</div><div class="line">            end  = _parameters.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> it-&gt;second;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!_initialized)</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _m_card;</div><div class="line">        <span class="keyword">delete</span> _p_card;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _eq_sys;</div><div class="line">        <span class="keyword">delete</span> _mesh;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _discipline;</div><div class="line">        <span class="keyword">delete</span> _sys_init;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _level_set_function;</div><div class="line">        <span class="keyword">delete</span> _level_set_vel;</div><div class="line">        <span class="keyword">delete</span> _level_set_sys_init;</div><div class="line">        <span class="keyword">delete</span> _indicator_sys_init;</div><div class="line">        <span class="keyword">delete</span> _indicator_discipline;</div><div class="line">        <span class="keyword">delete</span> _level_set_discipline;</div><div class="line">        <span class="keyword">delete</span> _filter;</div><div class="line">        <span class="keyword">delete</span> _level_set_eq_sys;</div><div class="line">        <span class="keyword">delete</span> _level_set_mesh;</div><div class="line">        <span class="keyword">delete</span> _output;</div><div class="line">        <span class="keyword">delete</span> _level_set_sys_init_on_str_mesh;</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_dv_params.size(); i++)</div><div class="line">            <span class="keyword">delete</span> _dv_params[i].second;</div><div class="line">    }</div><div class="line">    </div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="ex_5_wrappers_snopt"></a>
Wrappers for SNOPT</h2>
<div class="fragment"><div class="line">TopologyOptimizationLevelSet2D* _my_func_eval = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#if MAST_ENABLE_SNOPT == 1</span></div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">it_num = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_optim_obj(<span class="keywordtype">int</span>*    mode,</div><div class="line">           <span class="keywordtype">int</span>*    n,</div><div class="line">           <span class="keywordtype">double</span>* x,</div><div class="line">           <span class="keywordtype">double</span>* f,</div><div class="line">           <span class="keywordtype">double</span>* g,</div><div class="line">           <span class="keywordtype">int</span>*    nstate) {</div></div><!-- fragment --><p>make sure that the global variable has been setup</p>
<div class="fragment"><div class="line">libmesh_assert(_my_func_eval);</div></div><!-- fragment --><p>initialize the local variables</p>
<div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">obj = 0.;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_vars  =  _my_func_eval-&gt;n_vars(),</div><div class="line">n_con   =  _my_func_eval-&gt;n_eq()+_my_func_eval-&gt;n_ineq();</div><div class="line"></div><div class="line">libmesh_assert_equal_to(*n, n_vars);</div><div class="line"></div><div class="line">std::vector&lt;Real&gt;</div><div class="line">dvars   (*n,    0.),</div><div class="line">obj_grad(*n,    0.),</div><div class="line">fvals   (n_con, 0.),</div><div class="line">grads   (0);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt;</div><div class="line">eval_grads(n_con);</div><div class="line">std::fill(eval_grads.begin(), eval_grads.end(), <span class="keyword">false</span>);</div></div><!-- fragment --><p>copy the dvars</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">    dvars[i] = x[i];</div><div class="line"></div><div class="line"></div><div class="line">_my_func_eval-&gt;_evaluate_wrapper(dvars,</div><div class="line">                                 obj,</div><div class="line">                                 *mode&gt;0,       <span class="comment">// request the derivatives of obj</span></div><div class="line">                                 obj_grad,</div><div class="line">                                 fvals,</div><div class="line">                                 eval_grads,</div><div class="line">                                 grads);</div></div><!-- fragment --><p>now copy them back as necessary</p>
<div class="fragment"><div class="line">*f  = obj;</div><div class="line"><span class="keywordflow">if</span> (*mode &gt; 0) {</div></div><!-- fragment --><p> output data to the file </p><div class="fragment"><div class="line">        _my_func_eval-&gt;_output_wrapper(it_num, dvars, obj, fvals, <span class="keyword">true</span>);</div><div class="line">        it_num++;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">            g[i] = obj_grad[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (obj &gt; 1.e5) *mode = -1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_optim_con(<span class="keywordtype">int</span>*    mode,</div><div class="line">           <span class="keywordtype">int</span>*    ncnln,</div><div class="line">           <span class="keywordtype">int</span>*    n,</div><div class="line">           <span class="keywordtype">int</span>*    ldJ,</div><div class="line">           <span class="keywordtype">int</span>*    needc,</div><div class="line">           <span class="keywordtype">double</span>* x,</div><div class="line">           <span class="keywordtype">double</span>* c,</div><div class="line">           <span class="keywordtype">double</span>* cJac,</div><div class="line">           <span class="keywordtype">int</span>*    nstate) {</div></div><!-- fragment --><p>make sure that the global variable has been setup</p>
<div class="fragment"><div class="line">libmesh_assert(_my_func_eval);</div></div><!-- fragment --><p>initialize the local variables</p>
<div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">obj = 0.;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_vars  =  _my_func_eval-&gt;n_vars(),</div><div class="line">n_con   =  _my_func_eval-&gt;n_eq()+_my_func_eval-&gt;n_ineq();</div><div class="line"></div><div class="line">libmesh_assert_equal_to(    *n, n_vars);</div><div class="line">libmesh_assert_equal_to(*ncnln, n_con);</div><div class="line"></div><div class="line">std::vector&lt;Real&gt;</div><div class="line">dvars   (*n,    0.),</div><div class="line">obj_grad(*n,    0.),</div><div class="line">fvals   (n_con, 0.),</div><div class="line">grads   (n_vars*n_con, 0.);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt;</div><div class="line">eval_grads(n_con);</div><div class="line">std::fill(eval_grads.begin(), eval_grads.end(), *mode&gt;0);</div></div><!-- fragment --><p>copy the dvars</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">    dvars[i] = x[i];</div><div class="line"></div><div class="line"></div><div class="line">_my_func_eval-&gt;_evaluate_wrapper(dvars,</div><div class="line">                                 obj,</div><div class="line">                                 <span class="keyword">false</span>,       <span class="comment">// request the derivatives of obj</span></div><div class="line">                                 obj_grad,</div><div class="line">                                 fvals,</div><div class="line">                                 eval_grads,</div><div class="line">                                 grads);</div></div><!-- fragment --><p>now copy them back as necessary</p>
<p>first the constraint functions</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_con; i++)</div><div class="line">    c[i] = fvals[i];</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (*mode &gt; 0) {</div></div><!-- fragment --><p>next, the constraint gradients</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_con*n_vars; i++)</div><div class="line">            cJac[i] = grads[i];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (obj &gt; 1.e5) *mode = -1;</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="ex_5_main"></a>
Main function</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line"></div><div class="line">    libMesh::LibMeshInit init(argc, argv);</div><div class="line"></div><div class="line">    MAST::Examples::GetPotWrapper</div><div class="line">    input(argc, argv, <span class="stringliteral">&quot;input&quot;</span>);</div><div class="line"></div><div class="line">    TopologyOptimizationLevelSet2D top_opt(init.comm(), input);</div><div class="line">    _my_func_eval = &amp;top_opt;</div></div><!-- fragment --><p> <a class="el" href="class_m_a_s_t_1_1_n_l_opt_optimization_interface.html">MAST::NLOptOptimizationInterface</a> optimizer(NLOPT_LD_SLSQP); </p><div class="fragment"><div class="line">std::unique_ptr&lt;MAST::OptimizationInterface&gt;</div><div class="line">optimizer;</div><div class="line"></div><div class="line">std::string</div><div class="line">s          = input(<span class="stringliteral">&quot;optimizer&quot;</span>, <span class="stringliteral">&quot;optimizer to use in the example&quot;</span>, <span class="stringliteral">&quot;gcmma&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;gcmma&quot;</span>) {</div><div class="line"></div><div class="line">    optimizer.reset(<span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_g_c_m_m_a_optimization_interface.html">MAST::GCMMAOptimizationInterface</a>);</div><div class="line">    </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    max_inner_iters        = input(<span class="stringliteral">&quot;max_inner_iters&quot;</span>, <span class="stringliteral">&quot;maximum inner iterations in GCMMA&quot;</span>, 15);</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    constr_penalty         = input(<span class="stringliteral">&quot;constraint_penalty&quot;</span>, <span class="stringliteral">&quot;constraint penalty in GCMMA&quot;</span>, 50.),</div><div class="line">    initial_rel_step       = input(<span class="stringliteral">&quot;initial_rel_step&quot;</span>, <span class="stringliteral">&quot;initial step size in GCMMA&quot;</span>, 1.e-2),</div><div class="line">    asymptote_reduction    = input(<span class="stringliteral">&quot;asymptote_reduction&quot;</span>, <span class="stringliteral">&quot;reduction of aymptote in GCMMA&quot;</span>, 0.7),</div><div class="line">    asymptote_expansion    = input(<span class="stringliteral">&quot;asymptote_expansion&quot;</span>, <span class="stringliteral">&quot;expansion of asymptote in GCMMA&quot;</span>, 1.2);</div><div class="line">    </div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;constraint_penalty&quot;</span>,  constr_penalty);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;initial_rel_step&quot;</span>,  initial_rel_step);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;asymptote_reduction&quot;</span>,  asymptote_reduction);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;asymptote_expansion&quot;</span>,  asymptote_expansion);</div><div class="line">    optimizer-&gt;set_integer_parameter(   <span class="stringliteral">&quot;max_inner_iters&quot;</span>, max_inner_iters);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;snopt&quot;</span>) {</div><div class="line">    </div><div class="line">    optimizer.reset(<span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_n_p_s_o_l_optimization_interface.html">MAST::NPSOLOptimizationInterface</a>);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    libMesh::out</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Unrecognized optimizer specified: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    libmesh_error();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (optimizer.get()) {</div><div class="line">    </div><div class="line">    optimizer-&gt;attach_function_evaluation_object(top_opt);</div></div><!-- fragment --><p> std::vector&lt;Real&gt; xx1(top_opt.n_vars()), xx2(top_opt.n_vars()); top_opt.init_dvar(xx1, xx2, xx2); top_opt.initialize_dv_from_output_file("output1.txt", 24, xx1); top_opt.verify_gradients(xx1); </p><div class="fragment"><div class="line">optimizer-&gt;optimize();</div></div><!-- fragment --><p> top_opt.parametric_line_study("output1.txt", 0, 450, 500); </p><div class="fragment"><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="TutorialsPage.html">Tutorials for MAST</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
