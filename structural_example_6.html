<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAST: 2D SIMP topology optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structural_example_6.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">2D SIMP topology optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ex_6_init_mesh">Mesh Generation</a><ul><li class="level2"><a href="#ex_6_inplane_mesh">Inplane problem</a></li>
<li class="level2"><a href="#ex_6_bracket_mesh">Bracket</a></li>
<li class="level2"><a href="#ex_6_eyebar_mesh">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_6_system_discipline">System and Discipline</a></li>
<li class="level1"><a href="#ex_6_dirichlet">Dirichlet Constraints</a><ul><li class="level2"><a href="#ex_6_inplane_dirichlet">Inplane</a></li>
<li class="level2"><a href="#ex_6_truss_dirichlet">Truss</a></li>
<li class="level2"><a href="#ex_6_bracket_dirichlet">Bracket</a></li>
<li class="level2"><a href="#ex_6_eyebar_dirichlet">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_6_loading">Loading</a><ul><li class="level2"><a href="#ex_6_inplane_loading">Inplane</a></li>
<li class="level2"><a href="#ex_6_bracket_loading">Bracket</a></li>
<li class="level2"><a href="#ex_6_eyebar_loading">Eyebar</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_6_properties">Properties</a><ul><li class="level2"><a href="#ex_6_material_properties">Material Properties</a></li>
<li class="level2"><a href="#ex_6_section_properties">Section Properties</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_6_initial_solution">Initial Density field</a><ul><li class="level2"><a href="#ex_6_inplane_initial_level_set">Inplane</a></li>
<li class="level2"><a href="#ex_6_truss_initial_level_set">Truss</a></li>
<li class="level2"><a href="#ex_6_bracket_initial_level_set">Bracket</a></li>
<li class="level2"><a href="#ex_6_eyebar_initial_level_set">Eyebar</a></li>
<li class="level2"><a href="#ex_6_design_variable_init">Design Variables</a></li>
<li class="level2"><a href="#ex_6_function_evaluation">Function Evaluation</a></li>
<li class="level2"><a href="#ex_6_volume_sensitivity">Sensitivity of Material Volume</a></li>
<li class="level2"><a href="#ex_6_stress_sensitivity">Sensitivity of Stress and Eigenvalues</a></li>
<li class="level2"><a href="#ex_6_design_output">Output of Design Iterate</a></li>
</ul>
</li>
<li class="level1"><a href="#ex_6_initialization">Initialization</a><ul><li class="level2"><a href="#ex_6_constructor">Constructor</a></li>
<li class="level2"><a href="#ex_6_destructor">Destructor</a></li>
<li class="level2"><a href="#ex_6_wrappers_snopt">Wrappers for SNOPT</a></li>
<li class="level2"><a href="#ex_6_main">Main function</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This example computes the optimal topology of a structure subject to specified boundary conditions (Dirichlet and Neumann).</p>
<p>An element-wise density is used to parameterize the topology.</p>
<p>Elasticity function with the penalty term </p><div class="fragment"><div class="line"><span class="keyword">class </span>ElasticityFunction:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ElasticityFunction(<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> E0, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> rho_min, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> penalty,</div><div class="line">                       <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>&amp; rho,</div><div class="line">                       <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>&amp; drho):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(<span class="stringliteral">&quot;E&quot;</span>),</div><div class="line">    _E0(E0),</div><div class="line">    _rho_min(rho_min),</div><div class="line">    _penalty(penalty),</div><div class="line">    _rho(rho),</div><div class="line">    _drho(drho) { }</div><div class="line">    <span class="keyword">virtual</span> ~ElasticityFunction(){}</div><div class="line">    <span class="keywordtype">void</span> set_penalty_val(<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> penalty) {_penalty = penalty;}</div><div class="line">    </div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html#ac2e70abae3adab96d41fa17a444464f0">depends_on</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>;}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">        <a class="code" href="mast__data__types_8h.html#abc8ad2bc4221d7400e5306159e28e588">RealVectorX</a> v1;</div><div class="line">        _rho(p, t, v1);</div><div class="line">        </div><div class="line">        v = _E0 * (_rho_min + (1.-_rho_min) * pow(v1(0), _penalty));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f,</div><div class="line">                            <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        </div><div class="line">        <a class="code" href="mast__data__types_8h.html#abc8ad2bc4221d7400e5306159e28e588">RealVectorX</a> v1, dv1;</div><div class="line">        _rho(p, t, v1);</div><div class="line">        _drho(p, t, dv1);</div><div class="line">        </div><div class="line">        v = _E0 * (1.-_rho_min) * _penalty * pow(v1(0), _penalty-1.) * dv1(0);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                    _E0; <span class="comment">// value of the material Young&#39;s modulus</span></div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                    _rho_min; <span class="comment">// lower limit on density</span></div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                    _penalty; <span class="comment">// value of penalty term</span></div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a> &amp;_rho;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a> &amp;_drho;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ElementParameterDependence:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_assembly_base_1_1_elem_parameter_dependence.html">MAST::AssemblyBase::ElemParameterDependence</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ElementParameterDependence(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>&amp; filter):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::AssemblyBase::ElemParameterDependence(true), _filter(filter) {}</div><div class="line">    <span class="keyword">virtual</span> ~ElementParameterDependence() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> if_elem_depends_on_parameter(<span class="keyword">const</span> libMesh::Elem&amp; e,</div><div class="line">                                              <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; p)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a></div><div class="line">        &amp;p_ls = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>&amp;<span class="keyword">&gt;</span>(p);</div><div class="line">        </div><div class="line">        <span class="keywordflow">return</span> _filter.<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a688aed9a10f25dc876bf5d63781c948b">if_elem_in_domain_of_influence</a>(e, *p_ls.<a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html#aea6c707fc12f646008d59d124138bd3c">level_set_node</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>&amp; _filter;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>TopologyOptimizationSIMP2D:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_function_evaluation.html">MAST::FunctionEvaluation</a> {</div><div class="line">    </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    </div><div class="line">    <span class="keywordtype">bool</span>                                      _initialized;</div><div class="line">    MAST::Examples::GetPotWrapper&amp;            _input;</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _length;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _height;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _obj_scaling;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _stress_penalty;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _perimeter_penalty;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _stress_lim;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _p_val, _vm_rho;</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _vf;      <span class="comment">// volume fraction</span></div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                                      _rho_min; <span class="comment">// lower limit on density</span></div><div class="line"></div><div class="line">    ElasticityFunction*                       _Ef;</div><div class="line">    libMesh::UnstructuredMesh*                _mesh;</div><div class="line">    </div><div class="line">    libMesh::EquationSystems*                 _eq_sys;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>*                    _sys;</div><div class="line">    libMesh::System*                          _density_sys;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a>*     _sys_init;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>*              _discipline;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>*                         _filter;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_material_property_card_base.html">MAST::MaterialPropertyCardBase</a>*           _m_card;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_element_property_card_base.html">MAST::ElementPropertyCardBase</a>*            _p_card;</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>*                  _density_function;</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>*                  _density_sens_function;</div><div class="line">    libMesh::ExodusII_IO*                     _output;</div><div class="line">    </div><div class="line">    libMesh::FEType                           _fetype;</div><div class="line">    libMesh::FEType                           _density_fetype;</div><div class="line">    </div><div class="line">    std::vector&lt;MAST::Parameter*&gt;             _params_for_sensitivity;</div><div class="line">    std::map&lt;std::string, MAST::Parameter*&gt;   _parameters;</div><div class="line">    std::set&lt;MAST::FunctionBase*&gt;             _field_functions;</div><div class="line">    std::set&lt;MAST::BoundaryConditionBase*&gt;    _boundary_conditions;</div><div class="line">    std::set&lt;unsigned int&gt;                    _dv_dof_ids;</div><div class="line">    </div><div class="line">    std::vector&lt;std::pair&lt;unsigned int, MAST::Parameter*&gt;&gt;  _dv_params;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --> <h1><a class="anchor" id="ex_6_init_mesh"></a>
Mesh Generation</h1>
<p>This creates the mesh for the specified problem type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh() {</div></div><!-- fragment --><p> The mesh is created using classes written in <a class="el" href="namespace_m_a_s_t.html">MAST</a>. The particular mesh to be used can be selected using the input parameter <code>mesh=val</code>, where <code>val</code> can be one of the following:</p><ul>
<li><code>inplane</code> inplane structure with load on top and left and right boundaries constrained</li>
<li><code>bracket</code> L-bracket</li>
</ul>
<div class="fragment"><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, bracket}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_mesh_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_mesh_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_mesh_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_inplane_mesh"></a>
Inplane problem</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_inplane()  {</div><div class="line">    </div><div class="line">    _mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div></div><!-- fragment --><p>identify the element type from the input file or from the order of the element</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">nx_divs = _input(<span class="stringliteral">&quot;nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along x-axis&quot;</span>, 20),</div><div class="line">ny_divs = _input(<span class="stringliteral">&quot;ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along y-axis&quot;</span>, 20);</div><div class="line"></div><div class="line">_length = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">_height = _input(<span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3);</div><div class="line"></div><div class="line">std::string</div><div class="line">t = _input(<span class="stringliteral">&quot;elem_type&quot;</span>, <span class="stringliteral">&quot;type of geometric element in the mesh&quot;</span>, <span class="stringliteral">&quot;quad4&quot;</span>);</div><div class="line"></div><div class="line">libMesh::ElemType</div><div class="line">e_type = libMesh::Utility::string_to_enum&lt;libMesh::ElemType&gt;(t);</div></div><!-- fragment --><p>if high order FE is used, libMesh requires atleast a second order geometric element.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::QUAD4)</div><div class="line">    e_type = libMesh::QUAD9;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::TRI3)</div><div class="line">    e_type = libMesh::TRI6;</div></div><!-- fragment --><p>initialize the mesh with one element</p>
<div class="fragment"><div class="line">    libMesh::MeshTools::Generation::build_square(*_mesh,</div><div class="line">                                                 nx_divs, ny_divs,</div><div class="line">                                                 0, _length,</div><div class="line">                                                 0, _height,</div><div class="line">                                                 e_type);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_bracket_mesh"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_bracket() {</div><div class="line"></div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        nx_divs = _input(<span class="stringliteral">&quot;nx_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along x-axis&quot;</span>, 20),</div><div class="line">        ny_divs = _input(<span class="stringliteral">&quot;ny_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along y-axis&quot;</span>, 20);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (nx_divs%10 != 0 || ny_divs%10 != 0) libmesh_error();</div><div class="line">    }</div><div class="line">    </div><div class="line">    _init_mesh_inplane();</div><div class="line">    _delete_elems_from_bracket_mesh(*_mesh);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _delete_elems_from_bracket_mesh(libMesh::MeshBase &amp;mesh) {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    tol     = 1.e-12,</div><div class="line">    x       = -1.,</div><div class="line">    y       = -1.,</div><div class="line">    length  = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">    width   = _input( <span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3),</div><div class="line">    l_frac  = 0.4,</div><div class="line">    w_frac  = 0.4,</div><div class="line">    x_lim   = length * l_frac,</div><div class="line">    y_lim   =  width * (1.-w_frac);</div></div><!-- fragment --><p>now, remove elements that are outside of the L-bracket domain</p>
<div class="fragment"><div class="line">libMesh::MeshBase::element_iterator</div><div class="line">e_it   = mesh.elements_begin(),</div><div class="line">e_end  = mesh.elements_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; e_it!=e_end; e_it++) {</div><div class="line">    </div><div class="line">    libMesh::Elem* elem = *e_it;</div><div class="line">    x = length;</div><div class="line">    y = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elem-&gt;n_nodes(); i++) {</div><div class="line">        <span class="keyword">const</span> libMesh::Node&amp; n = elem-&gt;node_ref(i);</div><div class="line">        <span class="keywordflow">if</span> (x &gt; n(0)) x = n(0);</div><div class="line">        <span class="keywordflow">if</span> (y &lt; n(1)) y = n(1);</div><div class="line">    }</div></div><!-- fragment --><p>delete element if the lowest x,y locations are outside of the bracket domain</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (x &gt;= x_lim &amp;&amp; y&lt;= y_lim)</div><div class="line">        mesh.delete_elem(elem);</div><div class="line">}</div><div class="line"></div><div class="line">mesh.prepare_for_use();</div></div><!-- fragment --><p>add the two additional boundaries to the boundary info so that we can apply loads on them</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    facing_right = <span class="keyword">false</span>,</div><div class="line">    facing_down  = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    e_it   = mesh.elements_begin();</div><div class="line">    e_end  = mesh.elements_end();</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> ( ; e_it != e_end; e_it++) {</div><div class="line">        </div><div class="line">        libMesh::Elem* elem = *e_it;</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!elem-&gt;on_boundary()) <span class="keywordflow">continue</span>;</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elem-&gt;n_sides(); i++) {</div><div class="line">            </div><div class="line">            <span class="keywordflow">if</span> (elem-&gt;neighbor_ptr(i)) <span class="keywordflow">continue</span>;</div><div class="line">            </div><div class="line">            std::unique_ptr&lt;libMesh::Elem&gt; s(elem-&gt;side_ptr(i).release());</div><div class="line">            </div><div class="line">            <span class="keyword">const</span> libMesh::Point p = s-&gt;centroid();</div><div class="line">            </div><div class="line">            facing_right = <span class="keyword">true</span>;</div><div class="line">            facing_down  = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;s-&gt;n_nodes(); j++) {</div><div class="line">                <span class="keyword">const</span> libMesh::Node&amp; n = s-&gt;node_ref(j);</div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (n(0) &lt; x_lim ||  n(1) &gt; y_lim) {</div><div class="line">                    facing_right = <span class="keyword">false</span>;</div><div class="line">                    facing_down  = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::fabs(n(0) - p(0)) &gt; tol)</div><div class="line">                    facing_right = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::fabs(n(1) - p(1)) &gt; tol)</div><div class="line">                    facing_down = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keywordflow">if</span> (facing_right) mesh.boundary_info-&gt;add_side(elem, i, 4);</div><div class="line">            <span class="keywordflow">if</span> (facing_down) mesh.boundary_info-&gt;add_side(elem, i, 5);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    mesh.boundary_info-&gt;sideset_name(4) = <span class="stringliteral">&quot;facing_right&quot;</span>;</div><div class="line">    mesh.boundary_info-&gt;sideset_name(5) = <span class="stringliteral">&quot;facing_down&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_eyebar_mesh"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_mesh_eye_bar() {</div><div class="line">    </div><div class="line">    _mesh = <span class="keyword">new</span> libMesh::SerialMesh(this-&gt;comm());</div></div><!-- fragment --><p>identify the element type from the input file or from the order of the element</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_radial_divs  = _input(<span class="stringliteral">&quot;n_radial_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along radial direction&quot;</span>, 20),</div><div class="line">n_quarter_divs = _input(<span class="stringliteral">&quot;n_quarter_divs&quot;</span>, <span class="stringliteral">&quot;number of elements along height&quot;</span>, 20);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">radius   = 1.5,</div><div class="line">h_ratio  = _input(<span class="stringliteral">&quot;h_ratio&quot;</span>, <span class="stringliteral">&quot;ratio of radial element size at cylinder and at edge&quot;</span>, 2);</div><div class="line">_height  = 8.;</div><div class="line">_length  = _height*2;</div><div class="line"></div><div class="line">std::string</div><div class="line">t = _input(<span class="stringliteral">&quot;elem_type&quot;</span>, <span class="stringliteral">&quot;type of geometric element in the mesh&quot;</span>, <span class="stringliteral">&quot;quad4&quot;</span>);</div><div class="line"></div><div class="line">libMesh::ElemType</div><div class="line">e_type = libMesh::Utility::string_to_enum&lt;libMesh::ElemType&gt;(t);</div></div><!-- fragment --><p>if high order FE is used, libMesh requires atleast a second order geometric element.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::QUAD4)</div><div class="line">    e_type = libMesh::QUAD9;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (_fetype.order &gt; 1 &amp;&amp; e_type == libMesh::TRI3)</div><div class="line">    e_type = libMesh::TRI6;</div><div class="line"></div><div class="line">MAST::Examples::CylinderMesh2D cylinder;</div><div class="line">cylinder.mesh(radius, _height/2.,</div><div class="line">              n_radial_divs, n_quarter_divs, h_ratio,</div><div class="line">              *_mesh, e_type,</div><div class="line">              <span class="keyword">true</span>, _height, n_quarter_divs*2);</div></div><!-- fragment --><p>add the boundary ids for Dirichlet conditions</p>
<div class="fragment"><div class="line">libMesh::MeshBase::const_element_iterator</div><div class="line">e_it   = _mesh-&gt;elements_begin(),</div><div class="line">e_end  = _mesh-&gt;elements_end();</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol  = radius * 1.e-8;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; e_it != e_end; e_it++) {</div><div class="line">    </div><div class="line">    libMesh::Elem* elem = *e_it;</div><div class="line">    </div><div class="line">    std::unique_ptr&lt;libMesh::Elem&gt; edge(elem-&gt;side_ptr(1));</div><div class="line">    libMesh::Point p = edge-&gt;centroid();</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (std::fabs(p(0)-_height*1.5) &lt; tol &amp;&amp;</div><div class="line">        std::fabs(p(1)) &lt;= 1.) <span class="comment">// on the right edge</span></div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(elem, 1, 0);</div></div><!-- fragment --><p> check for the circumference of the circle where load will be applied </p><div class="fragment"><div class="line">        edge.reset(elem-&gt;side_ptr(3).release());</div><div class="line">        p = edge-&gt;centroid();</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> ((std::fabs(p.norm()-radius) &lt; 1.e-2) &amp;&amp;</div><div class="line">            p(0) &lt; 0.) <span class="comment">// left semi-circle</span></div><div class="line">            _mesh-&gt;boundary_info-&gt;add_side(elem, 3, 5);</div><div class="line">    }</div><div class="line">    </div><div class="line">    _mesh-&gt;boundary_info-&gt;sideset_name(0) = <span class="stringliteral">&quot;dirichlet&quot;</span>;</div><div class="line">    _mesh-&gt;boundary_info-&gt;sideset_name(5) = <span class="stringliteral">&quot;load&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_6_system_discipline"></a>
System and Discipline</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_system_and_discipline() {</div></div><!-- fragment --><p>make sure that the mesh has been initialized</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh);</div></div><!-- fragment --><p>create the equation system</p>
<div class="fragment"><div class="line">_eq_sys    = <span class="keyword">new</span>  libMesh::EquationSystems(*_mesh);</div></div><!-- fragment --><p>create the libmesh system and set the preferences for structural eigenvalue problems</p>
<div class="fragment"><div class="line">_sys       = &amp;(_eq_sys-&gt;add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;structural&quot;</span>));</div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a081daabdb69d1a500c926762fb1c6038">set_eigenproblem_type</a>(libMesh::GHEP);</div></div><!-- fragment --><p>initialize the system to the right set of variables</p>
<div class="fragment"><div class="line">_sys_init       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a>(*_sys,</div><div class="line">                                                           _sys-&gt;name(),</div><div class="line">                                                           _fetype);</div><div class="line">_discipline     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a>(*_eq_sys);</div></div><!-- fragment --><p>Initialize the system for level set function. A level set function is defined on a coarser mesh than the structural mesh. A level set function is assumed to be a first-order Lagrange finite element</p>
<div class="fragment"><div class="line">    _density_fetype      = libMesh::FEType(libMesh::FIRST, libMesh::LAGRANGE);</div><div class="line">    _density_sys         = &amp;(_eq_sys-&gt;add_system&lt;libMesh::ExplicitSystem&gt;(<span class="stringliteral">&quot;density&quot;</span>));</div><div class="line">    _density_sys-&gt;add_variable(<span class="stringliteral">&quot;rho&quot;</span>, _density_fetype);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_eq_sys() {</div><div class="line">    </div><div class="line">    _eq_sys-&gt;init();</div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a033caf367f2948d3f44e0d7e3ad1387e">eigen_solver</a>-&gt;set_position_of_spectrum(libMesh::LARGEST_MAGNITUDE);</div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#af33c95057746da93d4a5f65ffe02ec0f">set_exchange_A_and_B</a>(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p>variables added to the mesh</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_fetype() {</div></div><!-- fragment --><p> FEType to initialize the system. Get the order and type of element. </p><div class="fragment"><div class="line">    std::string</div><div class="line">    order_str   = _input(<span class="stringliteral">&quot;fe_order&quot;</span>, <span class="stringliteral">&quot;order of finite element shape basis functions&quot;</span>,    <span class="stringliteral">&quot;first&quot;</span>),</div><div class="line">    family_str  = _input(<span class="stringliteral">&quot;fe_family&quot;</span>,      <span class="stringliteral">&quot;family of finite element shape functions&quot;</span>, <span class="stringliteral">&quot;lagrange&quot;</span>);</div><div class="line">    </div><div class="line">    libMesh::Order</div><div class="line">    o  = libMesh::Utility::string_to_enum&lt;libMesh::Order&gt;(order_str);</div><div class="line">    libMesh::FEFamily</div><div class="line">    fe = libMesh::Utility::string_to_enum&lt;libMesh::FEFamily&gt;(family_str);</div><div class="line">    _fetype = libMesh::FEType(o, fe);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_6_dirichlet"></a>
Dirichlet Constraints</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_truss();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_dirichlet_conditions_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_inplane_dirichlet"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_inplane() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">    *dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(1, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _discipline-&gt;add_dirichlet_bc(1,  *dirichlet);</div><div class="line"></div><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(3, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _discipline-&gt;add_dirichlet_bc(3,  *dirichlet);</div><div class="line"></div><div class="line">    _discipline-&gt;init_system_dirichlet_bc(*_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_truss_dirichlet"></a>
Truss</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_truss() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    dirichlet_length_fraction = _input(<span class="stringliteral">&quot;truss_dirichlet_length_fraction&quot;</span>, <span class="stringliteral">&quot;length fraction of the truss boundary where dirichlet condition is applied&quot;</span>, 0.05);</div></div><!-- fragment --><p> identify the boundaries for dirichlet condition </p><div class="fragment"><div class="line">libMesh::MeshBase::const_element_iterator</div><div class="line">e_it   = _mesh-&gt;elements_begin(),</div><div class="line">e_end  = _mesh-&gt;elements_end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; e_it != e_end; e_it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Elem* e = *e_it;</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((*e-&gt;node_ptr(0))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">        e-&gt;centroid()(0) &lt;= _length*dirichlet_length_fraction)</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 6);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*e-&gt;node_ptr(1))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">             e-&gt;centroid()(0) &gt;= _length*(1.-dirichlet_length_fraction))</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 7);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((*e-&gt;node_ptr(0))(0) &lt; 1.e-8 &amp;&amp;</div><div class="line">        (*e-&gt;node_ptr(0))(1) &lt; 1.e-8 &amp;&amp;</div><div class="line">        e-&gt;centroid()(0) &lt;= _length*dirichlet_length_fraction)</div><div class="line">        _mesh-&gt;boundary_info-&gt;add_side(e, 0, 8);</div><div class="line">}</div><div class="line"></div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(6) = <span class="stringliteral">&quot;left_dirichlet&quot;</span>;</div><div class="line">_mesh-&gt;boundary_info-&gt;sideset_name(7) = <span class="stringliteral">&quot;right_dirichlet&quot;</span>;</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line">    std::vector&lt;unsigned int&gt; vars = {1, 2, 3, 4, 5};</div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">    *dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left support</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(6, vars);</div><div class="line">    _discipline-&gt;add_dirichlet_bc(6,  *dirichlet);</div><div class="line">    </div><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right support</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(7, vars);</div><div class="line">    _discipline-&gt;add_dirichlet_bc(7,  *dirichlet);</div><div class="line"></div><div class="line">    vars = {0};</div><div class="line">    dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// left support</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(8, vars);</div><div class="line">    _discipline-&gt;add_dirichlet_bc(8,  *dirichlet);</div><div class="line"></div><div class="line">    _discipline-&gt;init_system_dirichlet_bc(*_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_bracket_dirichlet"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_bracket() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">    *dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// bottom boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _discipline-&gt;add_dirichlet_bc(0,  *dirichlet);</div><div class="line">    </div><div class="line">    _discipline-&gt;init_system_dirichlet_bc(*_sys);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_eyebar_dirichlet"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_dirichlet_conditions_eye_bar() {</div></div><!-- fragment --><p>initialize Dirichlet conditions for structural system</p>
<div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a></div><div class="line">    *dirichlet  = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a>;   <span class="comment">// right boundary</span></div><div class="line">    dirichlet-&gt;<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, _sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_system_initialization.html#ac131e1b41eae1e9d0a0f2ce4efe02c15">vars</a>());</div><div class="line">    _discipline-&gt;add_dirichlet_bc(0,  *dirichlet);</div><div class="line">    </div><div class="line">    _discipline-&gt;init_system_dirichlet_bc(*_sys);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_6_loading"></a>
Loading</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_loads() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_loads_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_loads_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_loads_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="ex_6_inplane_loading"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>FluxLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FluxLoad(<span class="keyword">const</span> std::string&amp; nm, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> p, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l1, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> fraction):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(nm), _p(p), _l1(l1), _frac(fraction) { }</div><div class="line">    <span class="keyword">virtual</span> ~FluxLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (fabs(p(0)-_l1*0.5) &lt;= 0.5*_frac*_l1) v = _p;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> _p, _l1, _frac;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_inplane() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    frac    = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">    p_val   =  _input(<span class="stringliteral">&quot;pressure&quot;</span>, <span class="stringliteral">&quot;pressure on side of domain&quot;</span>,   2.e4);</div><div class="line">    </div><div class="line">    FluxLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> FluxLoad( <span class="stringliteral">&quot;pressure&quot;</span>, p_val, _length, frac);</div></div><!-- fragment --><p> initialize the load </p><div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(2, *p_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_bracket_loading"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>BracketLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BracketLoad(<span class="keyword">const</span> std::string&amp; nm, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> p, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> l1, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> fraction):</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(nm), _p(p), _l1(l1), _frac(fraction) { }</div><div class="line">    <span class="keyword">virtual</span> ~BracketLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (fabs(p(0) &gt;= _l1*(1.-_frac))) v = _p;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> _p, _l1, _frac;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_bracket() {</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    length  = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">    frac    = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.125),</div><div class="line">    p_val   = _input(<span class="stringliteral">&quot;pressure&quot;</span>, <span class="stringliteral">&quot;pressure on side of domain&quot;</span>,   5.e7);</div><div class="line">    </div><div class="line">    BracketLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> BracketLoad( <span class="stringliteral">&quot;pressure&quot;</span>, p_val, length, frac);</div></div><!-- fragment --><p>initialize the load</p>
<div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(5, *p_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_eyebar_loading"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>EyebarLoad:</div><div class="line"><span class="keyword">public</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html">MAST::FieldFunction</a>&lt;Real&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    EyebarLoad():</div><div class="line">    <a class="code" href="namespace_m_a_s_t.html">MAST</a>::FieldFunction&lt;<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&gt;(<span class="stringliteral">&quot;pressure&quot;</span>) { }</div><div class="line">    <span class="keyword">virtual</span> ~EyebarLoad() {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a7cb4d8f802f494b1504243e3aa2d7fe3">operator() </a>(<span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (p(0) &lt;= 0.) v = (-std::pow(p(1), 2) + std::pow(1.5, 2))*1.e6;</div><div class="line">        <span class="keywordflow">else</span> v = 0.;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_m_a_s_t_1_1_field_function.html#a277c10e4b2ef77c9288696143fd6a165">derivative</a>(<span class="keyword">const</span> <a class="code" href="class_m_a_s_t_1_1_function_base.html">MAST::FunctionBase</a>&amp; f, <span class="keyword">const</span> libMesh::Point&amp; p, <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> t, <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; v)<span class="keyword"> const </span>{</div><div class="line">        v = 0.;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_loads_eye_bar() {</div><div class="line">    </div><div class="line">    EyebarLoad</div><div class="line">    *press_f         = <span class="keyword">new</span> EyebarLoad();</div></div><!-- fragment --><p> initialize the load </p><div class="fragment"><div class="line">    <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a></div><div class="line">    *p_load          = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a>(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14aa4f09fd4e780fcff93f4362894b8b4c8">MAST::SURFACE_PRESSURE</a>);</div><div class="line">    </div><div class="line">    p_load-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*press_f);</div><div class="line">    _discipline-&gt;add_side_load(5, *p_load);</div><div class="line">    </div><div class="line">    _field_functions.insert(press_f);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_6_properties"></a>
Properties</h1>
<h2><a class="anchor" id="ex_6_material_properties"></a>
Material Properties</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_material() {</div><div class="line">    </div><div class="line">    _rho_min  = _input(<span class="stringliteral">&quot;rho_min&quot;</span>, <span class="stringliteral">&quot;lower limit on density variable&quot;</span>, 1.e-8);</div><div class="line"></div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    Eval      = _input(<span class="stringliteral">&quot;E&quot;</span>, <span class="stringliteral">&quot;modulus of elasticity&quot;</span>, 72.e9),</div><div class="line">    penalty   = _input(<span class="stringliteral">&quot;rho_penalty&quot;</span>, <span class="stringliteral">&quot;SIMP modulus of elasticity penalty&quot;</span>, 4.),</div><div class="line">    rhoval    = _input(<span class="stringliteral">&quot;rho&quot;</span>, <span class="stringliteral">&quot;material density&quot;</span>, 2700.),</div><div class="line">    nu_val    = _input(<span class="stringliteral">&quot;nu&quot;</span>, <span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>,  0.33),</div><div class="line">    kappa_val = _input(<span class="stringliteral">&quot;kappa&quot;</span>, <span class="stringliteral">&quot;shear correction factor&quot;</span>,  5./6.),</div><div class="line">    kval      = _input(<span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;thermal conductivity&quot;</span>,  1.e-2),</div><div class="line">    cpval     = _input(<span class="stringliteral">&quot;cp&quot;</span>, <span class="stringliteral">&quot;thermal capacitance&quot;</span>,  864.);</div><div class="line">    </div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a></div><div class="line">    *rho       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;rho&quot;</span>,      rhoval),</div><div class="line">    *nu        = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;nu&quot;</span>,       nu_val),</div><div class="line">    *kappa     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;kappa&quot;</span>, kappa_val),</div><div class="line">    *k         = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;k&quot;</span>,          kval),</div><div class="line">    *cp        = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;cp&quot;</span>,        cpval);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a></div><div class="line">    *rho_f   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(  <span class="stringliteral">&quot;rho&quot;</span>,    *rho),</div><div class="line">    *nu_f    = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(   <span class="stringliteral">&quot;nu&quot;</span>,     *nu),</div><div class="line">    *kappa_f = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;kappa&quot;</span>,  *kappa),</div><div class="line">    *k_f     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>( <span class="stringliteral">&quot;k_th&quot;</span>,      *k),</div><div class="line">    *cp_f    = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(   <span class="stringliteral">&quot;cp&quot;</span>,     *cp);</div><div class="line"></div><div class="line">    _Ef      = <span class="keyword">new</span> ElasticityFunction(Eval, _rho_min, penalty,</div><div class="line">                                      *_density_function,</div><div class="line">                                      *_density_sens_function);</div><div class="line">    </div><div class="line">    _parameters[  rho-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a673e80573ae59d74969d601b227545d1">name</a>()]     = rho;</div><div class="line">    _parameters[   nu-&gt;name()]     = nu;</div><div class="line">    _parameters[kappa-&gt;name()]     = kappa;</div><div class="line">    _parameters[    k-&gt;name()]     = k;</div><div class="line">    _parameters[   cp-&gt;name()]     = cp;</div><div class="line">    _field_functions.insert(_Ef);</div><div class="line">    _field_functions.insert(rho_f);</div><div class="line">    _field_functions.insert(nu_f);</div><div class="line">    _field_functions.insert(kappa_f);</div><div class="line">    _field_functions.insert(k_f);</div><div class="line">    _field_functions.insert(cp_f);</div><div class="line"></div><div class="line">    _m_card = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_isotropic_material_property_card.html">MAST::IsotropicMaterialPropertyCard</a>;</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*_Ef);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*rho_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*nu_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*kappa_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*k_f);</div><div class="line">    _m_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*cp_f);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_section_properties"></a>
Section Properties</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_section_property(){</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    th_v      =  _input(<span class="stringliteral">&quot;th&quot;</span>, <span class="stringliteral">&quot;thickness of 2D element&quot;</span>,  0.001);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a></div><div class="line">    *th       = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;th&quot;</span>, th_v),</div><div class="line">    *zero     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a>(<span class="stringliteral">&quot;zero&quot;</span>, 0.);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a></div><div class="line">    *th_f     = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;h&quot;</span>,       *th),</div><div class="line">    *hoff_f   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a>(<span class="stringliteral">&quot;off&quot;</span>,   *zero);</div><div class="line">    </div><div class="line">    </div><div class="line">    _parameters[th-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a673e80573ae59d74969d601b227545d1">name</a>()]    = th;</div><div class="line">    _parameters[zero-&gt;name()]  = zero;</div><div class="line">    _field_functions.insert(th_f);</div><div class="line">    _field_functions.insert(hoff_f);</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a></div><div class="line">    *p_card   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a>;</div><div class="line">    </div><div class="line">    _p_card   = p_card;</div></div><!-- fragment --><p> set nonlinear strain if requested </p><div class="fragment"><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    nonlinear = _input(<span class="stringliteral">&quot;if_nonlinear&quot;</span>, <span class="stringliteral">&quot;flag to turn on/off nonlinear strain&quot;</span>, <span class="keyword">false</span>);</div><div class="line">    <span class="keywordflow">if</span> (nonlinear) p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_element_property_card_base.html#a80330fb382ca84dc060eeb7ca6b784c6">set_strain</a>(<a class="code" href="namespace_m_a_s_t.html#af0d815f953a3c27690fda4e2748b357daca95d2120f66aa88bd88a58f0d76c4ed">MAST::NONLINEAR_STRAIN</a>);</div><div class="line">    </div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*th_f);</div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(*hoff_f);</div><div class="line">    p_card-&gt;<a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html#a902ba3f2c2a23289a7c394ccb8cc8162">set_material</a>(*_m_card);</div><div class="line">    _discipline-&gt;set_property_for_subdomain(0, *p_card);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ex_6_initial_solution"></a>
Initial Density field</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initialize_solution() {</div></div><!-- fragment --><p>initialize density field to a constant value of the specified volume fraction</p>
<div class="fragment"><div class="line">    _vf    = _input(<span class="stringliteral">&quot;volume_fraction&quot;</span>, <span class="stringliteral">&quot;upper limit for the voluem fraction&quot;</span>, 0.5);</div><div class="line"></div><div class="line">    _density_sys-&gt;solution-&gt;zero();</div><div class="line">    _density_sys-&gt;solution-&gt;add(_vf);</div><div class="line">    _density_sys-&gt;solution-&gt;close();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _init_phi_dvs() {</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    s  = _input(<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;type of mesh to be analyzed {inplane, truss, bracket, eye_bar}&quot;</span>, <span class="stringliteral">&quot;inplane&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;inplane&quot;</span> || s == <span class="stringliteral">&quot;truss&quot;</span>)</div><div class="line">        _init_phi_dvs_inplane();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;bracket&quot;</span>)</div><div class="line">        _init_phi_dvs_bracket();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;eye_bar&quot;</span>)</div><div class="line">        _init_phi_dvs_eye_bar();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        libmesh_error();</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    filter_radius          = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line">    _filter                = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_filter_base.html">MAST::FilterBase</a>(*_density_sys, filter_radius, _dv_dof_ids);</div><div class="line">    libMesh::NumericVector&lt;Real&gt;&amp; vec = _density_sys-&gt;add_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line">    vec = *_density_sys-&gt;solution;</div><div class="line">    vec.close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_inplane_initial_level_set"></a>
Inplane</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_inplane() {</div></div><!-- fragment --><p>this assumes that density variable has a constant value per element</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_density_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">sys_num = _density_sys-&gt;number(),</div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_density_sys-&gt;solution-&gt;size());</div><div class="line">_density_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the element values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _mesh-&gt;nodes_begin(),</div><div class="line">end = _mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_mesh-&gt;n_elem());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line"></div><div class="line">    dof_id                     = n.dof_number(sys_num, 0, 0);</div></div><!-- fragment --><p> only if node is not on the upper edge </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((n(1)+filter_radius &gt;= _height) &amp;&amp;</div><div class="line">    (n(0)-filter_radius &lt;= _length*.5*(1.+frac))   &amp;&amp;</div><div class="line">    (n(0)+filter_radius &gt;= _length*.5*(1.-frac))) {</div></div><!-- fragment --><p> set value at the material points to a small positive number </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                _density_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line"></div><div class="line">            std::ostringstream oss;</div><div class="line">            oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">            val  = local_phi[dof_id];</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line"></div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _density_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_truss_initial_level_set"></a>
Truss</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_truss() {</div></div><!-- fragment --><p>this assumes that density variable has a constant value per element</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_density_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.2),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">sys_num = _density_sys-&gt;number(),</div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_density_sys-&gt;solution-&gt;size());</div><div class="line">_density_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the element values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _mesh-&gt;nodes_begin(),</div><div class="line">end = _mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_mesh-&gt;n_elem());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line"></div><div class="line">    dof_id                     = n.dof_number(sys_num, 0, 0);</div></div><!-- fragment --><p> only if node is not on the upper edge </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((n(1)-filter_radius &lt;= 0.) &amp;&amp;</div><div class="line">    (n(0)-filter_radius &lt;= _length*.5*(1.+frac))   &amp;&amp;</div><div class="line">    (n(0)+filter_radius &gt;= _length*.5*(1.-frac))) {</div></div><!-- fragment --><p> set value at the material points to a small positive number </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                _density_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            </div><div class="line">            std::ostringstream oss;</div><div class="line">            oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">            val  = local_phi[dof_id];</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line"></div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _density_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_bracket_initial_level_set"></a>
Bracket</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_bracket() {</div><div class="line">    </div><div class="line">    libmesh_assert(_initialized);</div></div><!-- fragment --><p>this assumes that density variable has a constant value per element</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_density_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol           = 1.e-12,</div><div class="line">length        = _input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of domain along x-axis&quot;</span>, 0.3),</div><div class="line">height        = _input(<span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;length of domain along y-axis&quot;</span>, 0.3),</div><div class="line">l_frac        = 0.4,<span class="comment">//_input(&quot;length_fraction&quot;, &quot;fraction of length along x-axis that is in the bracket&quot;, 0.4),</span></div><div class="line">h_frac        = 0.4,<span class="comment">//_input( &quot;height_fraction&quot;, &quot;fraction of length along y-axis that is in the bracket&quot;, 0.4),</span></div><div class="line">x_lim         = length * l_frac,</div><div class="line">y_lim         =  height * (1.-h_frac),</div><div class="line">frac          = _input(<span class="stringliteral">&quot;load_length_fraction&quot;</span>, <span class="stringliteral">&quot;fraction of boundary length on which pressure will act&quot;</span>, 0.125),</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">sys_num = _density_sys-&gt;number(),</div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_density_sys-&gt;solution-&gt;size());</div><div class="line">_density_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the element values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _mesh-&gt;nodes_begin(),</div><div class="line">end = _mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_mesh-&gt;n_elem());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line"></div><div class="line">    dof_id                     = n.dof_number(sys_num, 0, 0);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((n(1)-filter_radius) &lt;= y_lim &amp;&amp; (n(0)+filter_radius) &gt;= length*(1.-frac)) {</div></div><!-- fragment --><p>set value at the constrained points to a small positive number material here</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">        dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">        _density_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">    val = local_phi[dof_id];</div></div><!-- fragment --><p>on the boundary, set everything to be zero, so that there is always a boundary there that the optimizer can move</p>
<div class="fragment"><div class="line">            <span class="keywordflow">if</span> (n(0) &lt; tol                     ||  <span class="comment">// left boundary</span></div><div class="line">                std::fabs(n(0) - length) &lt; tol ||  <span class="comment">// right boundary</span></div><div class="line">                std::fabs(n(1) - height) &lt; tol ||  <span class="comment">// top boundary</span></div><div class="line">                (n(0) &gt;= x_lim &amp;&amp; n(1) &lt;= y_lim)) {</div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                    dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                    _density_sys-&gt;solution-&gt;set(dof_id, _rho_min);</div><div class="line">                val = _rho_min;</div><div class="line">            }</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line">            </div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _density_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_eyebar_initial_level_set"></a>
Eyebar</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _init_phi_dvs_eye_bar() {</div><div class="line">    </div><div class="line">    libmesh_assert(_initialized);</div></div><!-- fragment --><p>this assumes that density variable has a constant value per element</p>
<div class="fragment"><div class="line">libmesh_assert_equal_to(_density_fetype.family, libMesh::LAGRANGE);</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">tol           = 1.e-6,</div><div class="line">filter_radius = _input(<span class="stringliteral">&quot;filter_radius&quot;</span>, <span class="stringliteral">&quot;radius of geometric filter for level set field&quot;</span>, 0.015);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">sys_num = _density_sys-&gt;number(),</div><div class="line">dof_id  = 0;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">val     = 0.;</div></div><!-- fragment --><p>all ranks will have DVs defined for all variables. So, we should be operating on a replicated mesh</p>
<div class="fragment"><div class="line">libmesh_assert(_mesh-&gt;is_replicated());</div><div class="line"></div><div class="line">std::vector&lt;Real&gt; local_phi(_density_sys-&gt;solution-&gt;size());</div><div class="line">_density_sys-&gt;solution-&gt;localize(local_phi);</div></div><!-- fragment --><p> iterate over all the element values iterate over all the element values </p><div class="fragment"><div class="line">libMesh::MeshBase::const_node_iterator</div><div class="line">it  = _mesh-&gt;nodes_begin(),</div><div class="line">end = _mesh-&gt;nodes_end();</div></div><!-- fragment --><p>maximum number of dvs is the number of nodes on the level set function mesh. We will evaluate the actual number of dvs</p>
<div class="fragment"><div class="line">_dv_params.reserve(_mesh-&gt;n_elem());</div><div class="line">_n_vars = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it!=end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = **it;</div><div class="line">    </div><div class="line">    dof_id                     = n.dof_number(sys_num, 0, 0);</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (((n.norm() &lt;= 1.5+filter_radius) &amp;&amp; n(0) &lt;= 0.) ||  <span class="comment">// circle</span></div><div class="line">        (std::fabs(n(0)-_height*1.5) &lt; filter_radius &amp;&amp;  <span class="comment">// right edge</span></div><div class="line">         std::fabs(n(1)) &lt;= 1.+filter_radius)) { <span class="comment">// dirichlet constraint</span></div></div><!-- fragment --><p>set value at the constrained points to material</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">            dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">            _density_sys-&gt;solution-&gt;set(dof_id, 1.e0);</div><div class="line">    }</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;dv_&quot;</span> &lt;&lt; _n_vars;</div><div class="line">    val = local_phi[dof_id];</div></div><!-- fragment --><p>on the boundary, set everything to be zero, so that there is always a boundary there that the optimizer can move</p>
<div class="fragment"><div class="line">            <span class="keywordflow">if</span> (std::fabs(n(0)+_height*0.5) &lt; tol    ||  <span class="comment">// left boundary</span></div><div class="line">                std::fabs(n(1)-_height*0.5) &lt; tol    ||  <span class="comment">// top boundary</span></div><div class="line">                std::fabs(n(1)+_height*0.5) &lt; tol    ||  <span class="comment">// bottom boundary</span></div><div class="line">                std::fabs(n(0)-_height*1.5) &lt; tol) {     <span class="comment">// right boundary</span></div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span> (dof_id &gt;= _density_sys-&gt;solution-&gt;first_local_index() &amp;&amp;</div><div class="line">                    dof_id &lt;  _density_sys-&gt;solution-&gt;last_local_index())</div><div class="line">                    _density_sys-&gt;solution-&gt;set(dof_id, _rho_min);</div><div class="line">                val = _rho_min;</div><div class="line">            }</div><div class="line">            </div><div class="line">            _dv_params.push_back(std::pair&lt;unsigned int, MAST::Parameter*&gt;());</div><div class="line">            _dv_params[_n_vars].first  = dof_id;</div><div class="line">            _dv_params[_n_vars].second = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_level_set_parameter.html">MAST::LevelSetParameter</a>(oss.str(), val, &amp;n);</div><div class="line">            _dv_params[_n_vars].second-&gt;<a class="code" href="class_m_a_s_t_1_1_function_base.html#a0528925b3e5763159352df948fca0b69">set_as_topology_parameter</a>(<span class="keyword">true</span>);</div><div class="line">            _dv_dof_ids.insert(dof_id);</div><div class="line">            </div><div class="line">            _n_vars++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    _density_sys-&gt;solution-&gt;close();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_design_variable_init"></a>
Design Variables</h2>
<pre class="fragment">  initializes the design variable vector, called by the 
  optimization interface. 
</pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> init_dvar(std::vector&lt;Real&gt;&amp; x,</div><div class="line">               std::vector&lt;Real&gt;&amp; xmin,</div><div class="line">               std::vector&lt;Real&gt;&amp; xmax) {</div><div class="line">    </div><div class="line">    x.resize(_n_vars);</div><div class="line">    xmin.resize(_n_vars);</div><div class="line">    xmax.resize(_n_vars);</div><div class="line">    </div><div class="line">    std::fill(xmin.begin(), xmin.end(),    _rho_min);</div><div class="line">    std::fill(xmax.begin(), xmax.end(),    1.e0);</div></div><!-- fragment --><p>now, check if the user asked to initialize dvs from a previous file</p>
<div class="fragment"><div class="line">    std::string</div><div class="line">    nm    =  _input(<span class="stringliteral">&quot;restart_optimization_file&quot;</span>, <span class="stringliteral">&quot;filename with optimization history for restart&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (nm.length()) {</div><div class="line">        </div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        iter = _input(<span class="stringliteral">&quot;restart_optimization_iter&quot;</span>, <span class="stringliteral">&quot;restart iteration number from file&quot;</span>, 0);</div><div class="line">        this-&gt;initialize_dv_from_output_file(nm, iter, x);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">            x[i] = (*_dv_params[i].second)();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_function_evaluation"></a>
Function Evaluation</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> evaluate(<span class="keyword">const</span> std::vector&lt;Real&gt;&amp; dvars,</div><div class="line">              <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>&amp; obj,</div><div class="line">              <span class="keywordtype">bool</span> eval_obj_grad,</div><div class="line">              std::vector&lt;Real&gt;&amp; obj_grad,</div><div class="line">              std::vector&lt;Real&gt;&amp; fvals,</div><div class="line">              std::vector&lt;bool&gt;&amp; eval_grads,</div><div class="line">              std::vector&lt;Real&gt;&amp; grads) {</div><div class="line">    </div><div class="line">    libMesh::out &lt;&lt; <span class="stringliteral">&quot;New Evaluation&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> copy DVs to level set function </p><div class="fragment"><div class="line">libMesh::NumericVector&lt;Real&gt;</div><div class="line">&amp;base_phi = _density_sys-&gt;get_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">    <span class="keywordflow">if</span> (_dv_params[i].first &gt;= base_phi.first_local_index() &amp;&amp;</div><div class="line">        _dv_params[i].first &lt;  base_phi.last_local_index())</div><div class="line">        base_phi.set(_dv_params[i].first, dvars[i]);</div><div class="line">base_phi.close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(base_phi, *_density_sys-&gt;solution);</div><div class="line">_density_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#a45a0f5907f61898b83d649050617357d">clear</a>();</div><div class="line">_density_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#ad05c1a6c795fbee828c4a3daae01fecd">init</a>(*_density_sys-&gt;solution);</div><div class="line">_sys-&gt;solution-&gt;zero();</div></div><!-- fragment --> <hr/>
<p> DO NOT zero out the gradient vector, since GCMMA needs it for the * subproblem solution * ********************************************************************* </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_implicit_assembly.html">MAST::NonlinearImplicitAssembly</a>                          nonlinear_assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_stress_assembly.html">MAST::StressAssembly</a>                                     stress_assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_nonlinear_assembly_elem_operations.html">MAST::StructuralNonlinearAssemblyElemOperations</a>          nonlinear_elem_ops;</div></div><!-- fragment --><p>first constrain the indicator function and solve</p>
<div class="fragment"><div class="line">nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">stress_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">nonlinear_elem_ops.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line"></div><div class="line"><a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html">MAST::StressStrainOutputBase</a>                    stress;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_compliance_output.html">MAST::ComplianceOutput</a>                          compliance;</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_output_assembly_elem_operations.html#ad7ce0a9393f174a5d19a52e6736ae988">set_participating_elements_to_all</a>();</div><div class="line">stress.<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html#a6a0a9dd59e698844a9fa12ed2e790991">set_aggregation_coefficients</a>(_p_val, 1., _vm_rho, _stress_lim) ;</div><div class="line">compliance.<a class="code" href="class_m_a_s_t_1_1_output_assembly_elem_operations.html#ad7ce0a9393f174a5d19a52e6736ae988">set_participating_elements_to_all</a>();</div><div class="line">compliance.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(*_discipline, *_sys_init);</div></div><!-- fragment --><p>evaluate the stress constraint</p>
<div class="fragment"><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;Static Solve&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">penalty          = _input(<span class="stringliteral">&quot;rho_penalty&quot;</span>, <span class="stringliteral">&quot;SIMP modulus of elasticity penalty&quot;</span>, 4.),</div><div class="line">stress_penalty   = _input(<span class="stringliteral">&quot;stress_rho_penalty&quot;</span>, <span class="stringliteral">&quot;SIMP modulus of elasticity penalty for stress evaluation&quot;</span>, 0.5);</div></div><!-- fragment --><p> set the elasticity penalty for solution </p><div class="fragment"><div class="line">_Ef-&gt;set_penalty_val(penalty);</div><div class="line"></div><div class="line">_sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aaaed1f33d18591f0f380516e1e2fbb8c">solve</a>(nonlinear_elem_ops, nonlinear_assembly);</div><div class="line">SNESConvergedReason</div><div class="line">r = <span class="keyword">dynamic_cast&lt;</span>libMesh::PetscNonlinearSolver&lt;Real&gt;&amp;<span class="keyword">&gt;</span></div><div class="line">(*_sys-&gt;nonlinear_solver).get_converged_reason();</div></div><!-- fragment --><p> if the solver diverged due to linear solve, then there is a problem with this geometry and we need to return with a high value set for the constraints </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (r == SNES_DIVERGED_LINEAR_SOLVE ||</div><div class="line">    _sys-&gt;final_nonlinear_residual() &gt; 1.e-1) {</div><div class="line">    </div><div class="line">    obj = 1.e11;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_ineq; i++)</div><div class="line">        fvals[i] = 1.e11;</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><p> evaluate compliance nonlinear_assembly.calculate_output(*_sys-&gt;solution, compliance); </p><div class="fragment"></div><!-- fragment --><p> set the elasticity penalty for stress evaluation </p><div class="fragment"><div class="line">_Ef-&gt;set_penalty_val(stress_penalty);</div><div class="line">nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#abbbc4fd5c13c458b2ef6c27636ee7510">calculate_output</a>(*_sys-&gt;solution, stress);</div></div><!-- fragment --><p>evaluate the objective</p>
<div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">max_vm = stress.<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html#ad36d673dc1fed1c3b72b60a7fd2868e6">get_maximum_von_mises_stress</a>(),</div><div class="line">vm_agg = stress.<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html#af53490adaa42b527b1a47f7032f1dbeb">output_total</a>(),</div><div class="line">vol    = 0.,</div><div class="line">comp   = compliance.<a class="code" href="class_m_a_s_t_1_1_compliance_output.html#aea42a279b0c213fa4a98a5f098c302b4">output_total</a>();</div><div class="line"></div><div class="line">_evaluate_volume(&amp;vol, <span class="keyword">nullptr</span>);</div></div><!-- fragment --><p> obj = _obj_scaling * comp; </p><div class="fragment"><div class="line">obj         = _obj_scaling * vol;</div></div><!-- fragment --><p> _obj_scaling * (vol+ _perimeter_penalty * per) + _stress_penalty * (vm_agg);///_stress_lim - 1.); </p><div class="fragment"><div class="line">fvals[0]  =  stress.<a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html#af53490adaa42b527b1a47f7032f1dbeb">output_total</a>()/_stress_lim - 1.;  <span class="comment">// g = sigma/sigma0-1 &lt;= 0</span></div></div><!-- fragment --><p> fvals[0] = stress.output_total(); // g = sigma/sigma0-1 &lt;= 0 fvals[0] = vol/_length/_height - _vf; // vol/vol0 - a &lt;= </p><div class="fragment"><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;volume: &quot;</span> &lt;&lt; vol &lt;&lt; std::endl;</div><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;max: &quot;</span>    &lt;&lt; max_vm &lt;&lt; <span class="stringliteral">&quot;  constr: &quot;</span> &lt;&lt; vm_agg</div><div class="line">&lt;&lt; std::endl;</div><div class="line">libMesh::out &lt;&lt; <span class="stringliteral">&quot;compliance: &quot;</span> &lt;&lt; comp &lt;&lt; std::endl;</div></div><!-- fragment --><p>evaluate the objective sensitivities, if requested</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (eval_obj_grad) {</div><div class="line">    </div><div class="line">    _evaluate_volume(<span class="keyword">nullptr</span>, &amp;obj_grad);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;grads.size(); i++) obj_grad[i] /= (_length*_height);</div></div><!-- fragment --><p> std::vector&lt;Real&gt; grad1(obj_grad.size(), 0.);</p>
<p>_evaluate_compliance_sensitivity(compliance, nonlinear_elem_ops, nonlinear_assembly, grad1);</p>
<p>for (unsigned int i=0; i&lt;obj_grad.size(); i++) obj_grad[i] += _obj_scaling * grad1[i]; </p><div class="fragment"><div class="line">}</div></div><!-- fragment --><p>check to see if the sensitivity of constraint is requested</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> if_grad_sens = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;eval_grads.size(); i++)</div><div class="line">    if_grad_sens = (if_grad_sens || eval_grads[i]);</div></div><!-- fragment --><p>evaluate the sensitivities for constraints</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (if_grad_sens) {</div><div class="line">    </div><div class="line">    _evaluate_stress_sensitivity(penalty,</div><div class="line">                                 stress_penalty,</div><div class="line">                                 stress,</div><div class="line">                                 nonlinear_elem_ops,</div><div class="line">                                 nonlinear_assembly,</div><div class="line">                                 grads);</div></div><!-- fragment --><p> _evaluate_volume(nullptr, &amp;grads); for (unsigned int i=0; i&lt;grads.size(); i++) grads[i] /= (_length*_height); </p><div class="fragment"><div class="line">}</div></div><!-- fragment --><p>also the stress data for plotting</p>
<div class="fragment"><div class="line">    stress_assembly.<a class="code" href="class_m_a_s_t_1_1_stress_assembly.html#a102f82da5f427b2702768d556d657ba8">update_stress_strain_data</a>(stress, *_sys-&gt;solution);</div><div class="line">    </div><div class="line">    _density_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#a45a0f5907f61898b83d649050617357d">clear</a>();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_volume_sensitivity"></a>
Sensitivity of Material Volume</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _evaluate_volume(<a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>               *volume,</div><div class="line">                      std::vector&lt;Real&gt;  *grad) {</div><div class="line"></div><div class="line">    libMesh::DofMap</div><div class="line">    &amp;dof_map  =  _density_sys-&gt;get_dof_map();</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> std::vector&lt;libMesh::dof_id_type&gt;</div><div class="line">    &amp;send_list = dof_map.get_send_list();</div><div class="line">    </div><div class="line">    std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">    local_sol(libMesh::NumericVector&lt;Real&gt;::build(_density_sys-&gt;comm()).release()),</div><div class="line">    local_dsol(libMesh::NumericVector&lt;Real&gt;::build(_density_sys-&gt;comm()).release());</div><div class="line">    </div><div class="line">    local_sol-&gt;init(_density_sys-&gt;n_dofs(),</div><div class="line">                    _density_sys-&gt;n_local_dofs(),</div><div class="line">                    send_list,</div><div class="line">                    <span class="keyword">false</span>,</div><div class="line">                    libMesh::GHOSTED);</div><div class="line"></div><div class="line">    local_dsol-&gt;init(_density_sys-&gt;n_dofs(),</div><div class="line">                     _density_sys-&gt;n_local_dofs(),</div><div class="line">                     send_list,</div><div class="line">                     <span class="keyword">false</span>,</div><div class="line">                     libMesh::GHOSTED);</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (volume) {</div><div class="line"></div><div class="line">        *volume = 0.;</div><div class="line">        </div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        sys_num = _density_sys-&gt;number();</div><div class="line">        </div><div class="line">        _density_sys-&gt;solution-&gt;localize(*local_sol, send_list);</div><div class="line">        </div><div class="line">        libMesh::MeshBase::element_iterator</div><div class="line">        it    =  _mesh-&gt;active_local_elements_begin(),</div><div class="line">        end   =  _mesh-&gt;active_local_elements_end();</div><div class="line">        </div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">        rho = 0.;</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> ( ; it != end; it++) {</div><div class="line">            </div><div class="line">            <span class="keyword">const</span> libMesh::Elem&amp; e = **it;</div></div><!-- fragment --><p> compute the average element density value </p><div class="fragment"><div class="line">rho = 0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;e.n_nodes(); i++) {</div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = *e.node_ptr(i);</div><div class="line">    rho += local_sol-&gt;el(n.dof_number(sys_num, 0, 0));</div><div class="line">}</div><div class="line">rho /= (1. * e.n_nodes());</div></div><!-- fragment --><p> use this density value to compute the volume </p><div class="fragment"><div class="line">        *volume  +=  e.volume() * rho;</div><div class="line">    }</div><div class="line">    </div><div class="line">    this-&gt;comm().sum(*volume);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (grad) {</div><div class="line">    </div><div class="line">    std::fill(grad-&gt;begin(), grad-&gt;end(), 0.);</div></div><!-- fragment --><p>iterate over each DV, create a sensitivity vector and calculate the volume sensitivity explicitly</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">dphi_base(_density_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">dphi_filtered(_density_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line"></div><div class="line">ElementParameterDependence dep(*_filter);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div><div class="line">    local_dsol-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div><div class="line"></div><div class="line">dphi_filtered-&gt;localize(*local_dsol, send_list);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">sys_num = _density_sys-&gt;number();</div><div class="line"></div><div class="line">libMesh::MeshBase::element_iterator</div><div class="line">it    =  _mesh-&gt;active_local_elements_begin(),</div><div class="line">end   =  _mesh-&gt;active_local_elements_end();</div><div class="line"></div><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">drho = 0.;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; it != end; it++) {</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> libMesh::Elem&amp; e = **it;</div></div><!-- fragment --><p> do not compute if the element is not in the domain of influence of the parameter </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!dep.if_elem_depends_on_parameter(e, *_dv_params[i].second))</div><div class="line">    <span class="keywordflow">continue</span>;</div></div><!-- fragment --><p> compute the average element density value </p><div class="fragment"><div class="line">drho = 0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;e.n_nodes(); i++) {</div><div class="line">    <span class="keyword">const</span> libMesh::Node&amp; n = *e.node_ptr(i);</div><div class="line">    drho += local_dsol-&gt;el(n.dof_number(sys_num, 0, 0));</div><div class="line">}</div><div class="line">drho /= (1. * e.n_nodes());</div></div><!-- fragment --><p> use this density value to compute the volume </p><div class="fragment"><div class="line">                (*grad)[i]  +=  e.volume() * drho;</div><div class="line">            }</div><div class="line">            </div><div class="line">            this-&gt;comm().sum((*grad)[i]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_stress_sensitivity"></a>
Sensitivity of Stress and Eigenvalues</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">_evaluate_stress_sensitivity</div><div class="line">(<span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                    penalty,</div><div class="line"> <span class="keyword">const</span> <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a>                    stress_penalty,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_stress_strain_output_base.html">MAST::StressStrainOutputBase</a>&amp; stress,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html">MAST::AssemblyElemOperations</a>&amp; nonlinear_elem_ops,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_nonlinear_implicit_assembly.html">MAST::NonlinearImplicitAssembly</a>&amp; nonlinear_assembly,</div><div class="line"> std::vector&lt;Real&gt;&amp; grads) {</div><div class="line">    </div><div class="line">    _sys-&gt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#a2eb7bf075f1c1e1f433963cc2dca5058">adjoint_solve</a>(nonlinear_elem_ops, stress, nonlinear_assembly, <span class="keyword">false</span>);</div><div class="line">    </div><div class="line">    std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">    dphi_base(_density_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">    dphi_filtered(_density_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line">    </div><div class="line">    ElementParameterDependence dep(*_filter);</div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a7a236e900be0ba6dbfe630ebb51e3152">attach_elem_parameter_dependence_object</a>(dep);</div></div><!-- fragment --><p>indices used by GCMMA follow this rule: grad_k = dfi/dxj , where k = j*NFunc + i</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div><div class="line"></div><div class="line">_density_sens_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#ad05c1a6c795fbee828c4a3daae01fecd">init</a>(*dphi_filtered);</div></div><!-- fragment --><p>stress sensitivity</p>
<p>set the elasticity penalty for solution, which is needed for computation of the residual sensitivity </p><div class="fragment"><div class="line">        _Ef-&gt;set_penalty_val(penalty);</div><div class="line"></div><div class="line">        grads[1*i+0] = 1./_stress_lim*</div><div class="line">        nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#ab6d7c383e893dca4de61657ee7f042cf">calculate_output_adjoint_sensitivity</a>(*_sys-&gt;solution,</div><div class="line">                                                                _sys-&gt;get_adjoint_solution(),</div><div class="line">                                                                *_dv_params[i].second,</div><div class="line">                                                                nonlinear_elem_ops,</div><div class="line">                                                                stress,</div><div class="line">                                                                <span class="keyword">false</span>);</div><div class="line">        </div><div class="line">        _Ef-&gt;set_penalty_val(stress_penalty);</div><div class="line">        nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0c8b29a632eb1b975005798b3862ad60">calculate_output_direct_sensitivity</a>(*_sys-&gt;solution,</div><div class="line">                                                               <span class="keyword">nullptr</span>,</div><div class="line">                                                               *_dv_params[i].second,</div><div class="line">                                                               stress);</div><div class="line">        grads[1*i+0] += 1./_stress_lim* stress.output_sensitivity_total(*_dv_params[i].second);</div><div class="line">        </div><div class="line">        stress.clear_sensitivity_data();</div><div class="line">        _density_sens_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#a45a0f5907f61898b83d649050617357d">clear</a>();</div><div class="line">    }</div><div class="line">    </div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#af8281c5eece58746b64293f8ccea49f3">clear_elem_parameter_dependence_object</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_evaluate_compliance_sensitivity</div><div class="line">(<a class="code" href="class_m_a_s_t_1_1_compliance_output.html">MAST::ComplianceOutput</a>&amp;                  compliance,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html">MAST::AssemblyElemOperations</a>&amp;            nonlinear_elem_ops,</div><div class="line"> <a class="code" href="class_m_a_s_t_1_1_nonlinear_implicit_assembly.html">MAST::NonlinearImplicitAssembly</a>&amp;         nonlinear_assembly,</div><div class="line"> std::vector&lt;Real&gt;&amp; grads) {</div></div><!-- fragment --><p> Adjoint solution for compliance = - X </p><div class="fragment"><div class="line">std::unique_ptr&lt;libMesh::NumericVector&lt;Real&gt;&gt;</div><div class="line">dphi_base(_density_sys-&gt;solution-&gt;zero_clone().release()),</div><div class="line">dphi_filtered(_density_sys-&gt;solution-&gt;zero_clone().release());</div><div class="line"></div><div class="line">ElementParameterDependence dep(*_filter);</div><div class="line">nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a7a236e900be0ba6dbfe630ebb51e3152">attach_elem_parameter_dependence_object</a>(dep);</div></div><!-- fragment --><p>indices used by GCMMA follow this rule: grad_k = dfi/dxj , where k = j*NFunc + i</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++) {</div><div class="line">    </div><div class="line">    dphi_base-&gt;zero();</div><div class="line">    dphi_filtered-&gt;zero();</div></div><!-- fragment --><p>set the value only if the dof corresponds to a local node</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (_dv_params[i].first &gt;=  dphi_base-&gt;first_local_index() &amp;&amp;</div><div class="line">    _dv_params[i].first &lt;   dphi_base-&gt;last_local_index())</div><div class="line">    dphi_base-&gt;set(_dv_params[i].first, 1.);</div><div class="line">dphi_base-&gt;close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(*dphi_base, *dphi_filtered);</div><div class="line"></div><div class="line">_density_sens_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#ad05c1a6c795fbee828c4a3daae01fecd">init</a>(*dphi_filtered);</div></div><!-- fragment --><p>compliance sensitivity</p>
<div class="fragment"><div class="line">        grads[i] = -1. *</div><div class="line">        nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#ab6d7c383e893dca4de61657ee7f042cf">calculate_output_adjoint_sensitivity</a>(*_sys-&gt;solution,</div><div class="line">                                                                *_sys-&gt;solution,</div><div class="line">                                                                *_dv_params[i].second,</div><div class="line">                                                                nonlinear_elem_ops,</div><div class="line">                                                                compliance);</div><div class="line">        _density_sens_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#a45a0f5907f61898b83d649050617357d">clear</a>();</div><div class="line">    }</div><div class="line">    </div><div class="line">    nonlinear_assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#af8281c5eece58746b64293f8ccea49f3">clear_elem_parameter_dependence_object</a>();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_design_output"></a>
Output of Design Iterate</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> output(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iter,</div><div class="line">            <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; x,</div><div class="line">            <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> obj,</div><div class="line">            <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; fval,</div><div class="line">            <span class="keywordtype">bool</span> if_write_to_optim_file) {</div><div class="line">    </div><div class="line">    libmesh_assert_equal_to(x.size(), _n_vars);</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    sys_time     = _sys-&gt;time;</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    output_name  = _input(<span class="stringliteral">&quot;output_file_root&quot;</span>, <span class="stringliteral">&quot;prefix of output file names&quot;</span>, <span class="stringliteral">&quot;output&quot;</span>),</div><div class="line">    modes_name   = output_name + <span class="stringliteral">&quot;modes.exo&quot;</span>;</div><div class="line">    </div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;output_optim.e-s.&quot;</span> &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; std::setw(5) &lt;&lt; iter ;</div></div><!-- fragment --><p>copy DVs to level set function</p>
<div class="fragment"><div class="line">libMesh::NumericVector&lt;Real&gt;</div><div class="line">&amp;base_phi = _density_sys-&gt;get_vector(<span class="stringliteral">&quot;base_values&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_n_vars; i++)</div><div class="line">    <span class="keywordflow">if</span> (_dv_params[i].first &gt;= base_phi.first_local_index() &amp;&amp;</div><div class="line">        _dv_params[i].first &lt;  base_phi.last_local_index())</div><div class="line">        base_phi.set(_dv_params[i].first, x[i]);</div><div class="line">base_phi.close();</div><div class="line">_filter-&gt;<a class="code" href="class_m_a_s_t_1_1_filter_base.html#a43ebfc42ebddac9e87b6a6fdde95822d">compute_filtered_values</a>(base_phi, *_density_sys-&gt;solution);</div><div class="line">_density_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#ad05c1a6c795fbee828c4a3daae01fecd">init</a>(*_density_sys-&gt;solution);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; eval_grads(this-&gt;n_ineq(), <span class="keyword">false</span>);</div><div class="line">std::vector&lt;Real&gt; f(this-&gt;n_ineq(), 0.), grads;</div><div class="line">this-&gt;evaluate(x, obj, <span class="keyword">false</span>, grads, f, eval_grads, grads);</div><div class="line"></div><div class="line">_sys-&gt;time = iter;</div><div class="line">_sys_init-&gt;<a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html#a1a3a8a8871255e3c19560908473658d8">get_stress_sys</a>().time = iter;</div></div><!-- fragment --><p> "1" is the number of time-steps in the file, as opposed to the time-step number. </p><div class="fragment"><div class="line">libMesh::ExodusII_IO(*_mesh).write_timestep(oss.str(), *_eq_sys, 1, (1.*iter));</div><div class="line"></div><div class="line">_density_function-&gt;<a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html#a45a0f5907f61898b83d649050617357d">clear</a>();</div></div><!-- fragment --><p>set the value of time back to its original value</p>
<div class="fragment"><div class="line">_sys-&gt;time = sys_time;</div></div><!-- fragment --><p>increment the parameter values</p>
<div class="fragment"><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        update_freq = _input(<span class="stringliteral">&quot;update_freq_optim_params&quot;</span>, <span class="stringliteral">&quot;number of iterations after which the optimization parameters are updated&quot;</span>, 50),</div><div class="line">        factor = iter/update_freq ;</div><div class="line">        <span class="keywordflow">if</span> (factor &gt; 0 &amp;&amp; iter%update_freq == 0) {</div><div class="line">            </div><div class="line">            <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">            p_val           = _input(<span class="stringliteral">&quot;constraint_aggregation_p_val&quot;</span>, <span class="stringliteral">&quot;value of p in p-norm stress aggregation&quot;</span>, 2.0),</div><div class="line">            vm_rho          = _input(<span class="stringliteral">&quot;constraint_aggregation_rho_val&quot;</span>, <span class="stringliteral">&quot;value of rho in p-norm stress aggregation&quot;</span>, 2.0),</div><div class="line">            constr_penalty  = _input(<span class="stringliteral">&quot;constraint_penalty&quot;</span>, <span class="stringliteral">&quot;constraint penalty in GCMMA&quot;</span>,      50.),</div><div class="line">            max_penalty     = _input(<span class="stringliteral">&quot;max_constraint_penalty&quot;</span>, <span class="stringliteral">&quot;maximum constraint penalty in GCMMA&quot;</span>,      1.e7),</div><div class="line">            initial_step    = _input(<span class="stringliteral">&quot;initial_rel_step&quot;</span>, <span class="stringliteral">&quot;initial relative step length in GCMMA&quot;</span>,      0.5),</div><div class="line">            min_step        = _input(<span class="stringliteral">&quot;minimum_rel_step&quot;</span>, <span class="stringliteral">&quot;minimum relative step length in GCMMA&quot;</span>,      0.001);</div><div class="line">            </div><div class="line">            constr_penalty = std::min(constr_penalty*pow(10, factor), max_penalty);</div><div class="line">            initial_step   = std::max(initial_step-0.01*factor, min_step);</div><div class="line">            _p_val         = std::min(p_val+2*factor, 10.);</div><div class="line">            _vm_rho        = std::min(vm_rho+factor*0.5, 2.);</div><div class="line">            libMesh::out</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Updated values: c = &quot;</span> &lt;&lt; constr_penalty</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  step = &quot;</span> &lt;&lt; initial_step</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  p = &quot;</span> &lt;&lt; _p_val</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  rho = &quot;</span> &lt;&lt; _vm_rho &lt;&lt; std::endl;</div><div class="line">            </div><div class="line">            _optimization_interface-&gt;set_real_parameter   ( <span class="stringliteral">&quot;constraint_penalty&quot;</span>,   constr_penalty);</div><div class="line">            _optimization_interface-&gt;set_real_parameter   (<span class="stringliteral">&quot;initial_rel_step&quot;</span>,        initial_step);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="class_m_a_s_t_1_1_function_evaluation.html#a8431337afb467479c95dbb0e1b1af4c6">MAST::FunctionEvaluation::output</a>(iter, x, obj/_obj_scaling, fval, if_write_to_optim_file);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="preprocessor">#if MAST_ENABLE_SNOPT == 1</span></div><div class="line">    MAST::FunctionEvaluation::funobj</div><div class="line">    get_objective_evaluation_function() {</div><div class="line">    </div><div class="line">        <span class="keywordflow">return</span> _optim_obj;</div><div class="line">    }</div><div class="line"></div><div class="line">    MAST::FunctionEvaluation::funcon</div><div class="line">    get_constraint_evaluation_function() {</div><div class="line">    </div><div class="line">        <span class="keywordflow">return</span> _optim_con;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h1><a class="anchor" id="ex_6_initialization"></a>
Initialization</h1>
<h2><a class="anchor" id="ex_6_constructor"></a>
Constructor</h2>
<div class="fragment"><div class="line">TopologyOptimizationSIMP2D(<span class="keyword">const</span> libMesh::Parallel::Communicator&amp; comm_in,</div><div class="line">                               MAST::Examples::GetPotWrapper&amp; input):</div><div class="line"><a class="code" href="namespace_m_a_s_t.html">MAST</a>::FunctionEvaluation             (comm_in),</div><div class="line">_initialized                         (false),</div><div class="line">_input                               (input),</div><div class="line">_length                              (0.),</div><div class="line">_height                              (0.),</div><div class="line">_obj_scaling                         (0.),</div><div class="line">_stress_penalty                      (0.),</div><div class="line">_perimeter_penalty                   (0.),</div><div class="line">_stress_lim                          (0.),</div><div class="line">_p_val                               (0.),</div><div class="line">_vm_rho                              (0.),</div><div class="line">_vf                                  (0.),</div><div class="line">_rho_min                             (0.),</div><div class="line">_mesh                                (nullptr),</div><div class="line">_eq_sys                              (nullptr),</div><div class="line">_sys                                 (nullptr),</div><div class="line">_sys_init                            (nullptr),</div><div class="line">_discipline                          (nullptr),</div><div class="line">_filter                              (nullptr),</div><div class="line">_m_card                              (nullptr),</div><div class="line">_p_card                              (nullptr),</div><div class="line">_output                              (nullptr) {</div><div class="line">    </div><div class="line">    libmesh_assert(!_initialized);</div></div><!-- fragment --><p>call the initialization routines for each component</p>
<div class="fragment"><div class="line">_init_fetype();</div><div class="line">_init_mesh();</div><div class="line">_init_system_and_discipline();</div><div class="line">_init_dirichlet_conditions();</div><div class="line">_init_eq_sys();</div></div><!-- fragment --><p> density function is used by elasticity modulus function. So, we initialize this here </p><div class="fragment"><div class="line">_density_function        = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>(*_density_sys, <span class="stringliteral">&quot;rho&quot;</span>);</div><div class="line">_density_sens_function   = <span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_mesh_field_function.html">MAST::MeshFieldFunction</a>(*_density_sys, <span class="stringliteral">&quot;rho&quot;</span>);</div><div class="line"></div><div class="line">_init_material();</div><div class="line">_init_loads();</div><div class="line">_init_section_property();</div><div class="line">_initialized = <span class="keyword">true</span>;</div></div><!-- fragment --><p>ask structure to use Mindlin bending operator</p>
<div class="fragment"><div class="line"><span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_m_a_s_t_1_1_element_property_card2_d.html">MAST::ElementPropertyCard2D</a>&amp;<span class="keyword">&gt;</span>(*_p_card).<a class="code" href="class_m_a_s_t_1_1_element_property_card2_d.html#a996d5416432c2e6c5b50b609e5036d50">set_bending_model</a>(<a class="code" href="namespace_m_a_s_t.html#a94a01c803186334c9074965d417ba049a40e284f45a3d0210bcb6dfd933d10e09">MAST::MINDLIN</a>);</div></div><!-- fragment --><p>now initialize the design data.</p>
<div class="fragment"></div><!-- fragment --><p>first, initialize the level set functions over the domain</p>
<div class="fragment"><div class="line">this-&gt;initialize_solution();</div></div><!-- fragment --><p>next, define a new parameter to define design variable for nodal level-set function value</p>
<div class="fragment"><div class="line">this-&gt;_init_phi_dvs();</div><div class="line"></div><div class="line">_obj_scaling           = 1./_length/_height;</div><div class="line">_stress_penalty        = _input(<span class="stringliteral">&quot;stress_penalty&quot;</span>, <span class="stringliteral">&quot;penalty value for stress_constraint&quot;</span>, 0.);</div><div class="line">_perimeter_penalty     = _input(<span class="stringliteral">&quot;perimeter_penalty&quot;</span>, <span class="stringliteral">&quot;penalty value for perimeter in the objective function&quot;</span>, 0.);</div><div class="line">_stress_lim            = _input(<span class="stringliteral">&quot;vm_stress_limit&quot;</span>, <span class="stringliteral">&quot;limit von-mises stress value&quot;</span>, 2.e8);</div><div class="line">_p_val                 = _input(<span class="stringliteral">&quot;constraint_aggregation_p_val&quot;</span>, <span class="stringliteral">&quot;value of p in p-norm stress aggregation&quot;</span>, 2.0);</div><div class="line">_vm_rho                = _input(<span class="stringliteral">&quot;constraint_aggregation_rho_val&quot;</span>, <span class="stringliteral">&quot;value of rho in p-norm stress aggregation&quot;</span>, 2.0);</div><div class="line">_output                = <span class="keyword">new</span> libMesh::ExodusII_IO(*_mesh);</div></div><!-- fragment --><p>two inequality constraints: stress and eigenvalue.</p>
<div class="fragment"><div class="line">    _n_ineq = 1;</div><div class="line">    </div><div class="line">    std::string</div><div class="line">    output_name = _input(<span class="stringliteral">&quot;output_file_root&quot;</span>, <span class="stringliteral">&quot;prefix of output file names&quot;</span>, <span class="stringliteral">&quot;output&quot;</span>);</div><div class="line">    output_name += <span class="stringliteral">&quot;_optim_history.txt&quot;</span>;</div><div class="line">    this-&gt;set_output_file(output_name);</div><div class="line">    </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_destructor"></a>
Destructor</h2>
<div class="fragment"><div class="line">    ~TopologyOptimizationSIMP2D() {</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::set&lt;MAST::BoundaryConditionBase*&gt;::iterator</div><div class="line">            it   = _boundary_conditions.begin(),</div><div class="line">            end  = _boundary_conditions.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> *it;</div><div class="line">        }</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::set&lt;MAST::FunctionBase*&gt;::iterator</div><div class="line">            it   = _field_functions.begin(),</div><div class="line">            end  = _field_functions.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> *it;</div><div class="line">        }</div><div class="line">        </div><div class="line">        {</div><div class="line">            std::map&lt;std::string, MAST::Parameter*&gt;::iterator</div><div class="line">            it   = _parameters.begin(),</div><div class="line">            end  = _parameters.end();</div><div class="line">            <span class="keywordflow">for</span> ( ; it!=end; it++)</div><div class="line">                <span class="keyword">delete</span> it-&gt;second;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!_initialized)</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _m_card;</div><div class="line">        <span class="keyword">delete</span> _p_card;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _eq_sys;</div><div class="line">        <span class="keyword">delete</span> _mesh;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _discipline;</div><div class="line">        <span class="keyword">delete</span> _sys_init;</div><div class="line">        </div><div class="line">        <span class="keyword">delete</span> _filter;</div><div class="line">        <span class="keyword">delete</span> _output;</div><div class="line">        <span class="keyword">delete</span> _density_function;</div><div class="line">        <span class="keyword">delete</span> _density_sens_function;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_dv_params.size(); i++)</div><div class="line">            <span class="keyword">delete</span> _dv_params[i].second;</div><div class="line">    }</div><div class="line">    </div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="ex_6_wrappers_snopt"></a>
Wrappers for SNOPT</h2>
<div class="fragment"><div class="line">TopologyOptimizationSIMP2D* _my_func_eval = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#if MAST_ENABLE_SNOPT == 1</span></div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">it_num = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_optim_obj(<span class="keywordtype">int</span>*    mode,</div><div class="line">           <span class="keywordtype">int</span>*    n,</div><div class="line">           <span class="keywordtype">double</span>* x,</div><div class="line">           <span class="keywordtype">double</span>* f,</div><div class="line">           <span class="keywordtype">double</span>* g,</div><div class="line">           <span class="keywordtype">int</span>*    nstate) {</div></div><!-- fragment --><p>make sure that the global variable has been setup</p>
<div class="fragment"><div class="line">libmesh_assert(_my_func_eval);</div></div><!-- fragment --><p>initialize the local variables</p>
<div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">obj = 0.;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_vars  =  _my_func_eval-&gt;n_vars(),</div><div class="line">n_con   =  _my_func_eval-&gt;n_eq()+_my_func_eval-&gt;n_ineq();</div><div class="line"></div><div class="line">libmesh_assert_equal_to(*n, n_vars);</div><div class="line"></div><div class="line">std::vector&lt;Real&gt;</div><div class="line">dvars   (*n,    0.),</div><div class="line">obj_grad(*n,    0.),</div><div class="line">fvals   (n_con, 0.),</div><div class="line">grads   (0);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt;</div><div class="line">eval_grads(n_con);</div><div class="line">std::fill(eval_grads.begin(), eval_grads.end(), <span class="keyword">false</span>);</div></div><!-- fragment --><p>copy the dvars</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">    dvars[i] = x[i];</div><div class="line"></div><div class="line"></div><div class="line">_my_func_eval-&gt;_evaluate_wrapper(dvars,</div><div class="line">                                 obj,</div><div class="line">                                 *mode&gt;0,       <span class="comment">// request the derivatives of obj</span></div><div class="line">                                 obj_grad,</div><div class="line">                                 fvals,</div><div class="line">                                 eval_grads,</div><div class="line">                                 grads);</div></div><!-- fragment --><p>now copy them back as necessary</p>
<div class="fragment"><div class="line">*f  = obj;</div><div class="line"><span class="keywordflow">if</span> (*mode &gt; 0) {</div></div><!-- fragment --><p> output data to the file </p><div class="fragment"><div class="line">        _my_func_eval-&gt;_output_wrapper(it_num, dvars, obj, fvals, <span class="keyword">true</span>);</div><div class="line">        it_num++;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">            g[i] = obj_grad[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (obj &gt; 1.e10) *mode = -1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">_optim_con(<span class="keywordtype">int</span>*    mode,</div><div class="line">           <span class="keywordtype">int</span>*    ncnln,</div><div class="line">           <span class="keywordtype">int</span>*    n,</div><div class="line">           <span class="keywordtype">int</span>*    ldJ,</div><div class="line">           <span class="keywordtype">int</span>*    needc,</div><div class="line">           <span class="keywordtype">double</span>* x,</div><div class="line">           <span class="keywordtype">double</span>* c,</div><div class="line">           <span class="keywordtype">double</span>* cJac,</div><div class="line">           <span class="keywordtype">int</span>*    nstate) {</div></div><!-- fragment --><p>make sure that the global variable has been setup</p>
<div class="fragment"><div class="line">libmesh_assert(_my_func_eval);</div></div><!-- fragment --><p>initialize the local variables</p>
<div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">obj = 0.;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_vars  =  _my_func_eval-&gt;n_vars(),</div><div class="line">n_con   =  _my_func_eval-&gt;n_eq()+_my_func_eval-&gt;n_ineq();</div><div class="line"></div><div class="line">libmesh_assert_equal_to(    *n, n_vars);</div><div class="line">libmesh_assert_equal_to(*ncnln, n_con);</div><div class="line"></div><div class="line">std::vector&lt;Real&gt;</div><div class="line">dvars   (*n,    0.),</div><div class="line">obj_grad(*n,    0.),</div><div class="line">fvals   (n_con, 0.),</div><div class="line">grads   (n_vars*n_con, 0.);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt;</div><div class="line">eval_grads(n_con);</div><div class="line">std::fill(eval_grads.begin(), eval_grads.end(), *mode&gt;0);</div></div><!-- fragment --><p>copy the dvars</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_vars; i++)</div><div class="line">    dvars[i] = x[i];</div><div class="line"></div><div class="line"></div><div class="line">_my_func_eval-&gt;_evaluate_wrapper(dvars,</div><div class="line">                                 obj,</div><div class="line">                                 <span class="keyword">false</span>,       <span class="comment">// request the derivatives of obj</span></div><div class="line">                                 obj_grad,</div><div class="line">                                 fvals,</div><div class="line">                                 eval_grads,</div><div class="line">                                 grads);</div></div><!-- fragment --><p>now copy them back as necessary</p>
<p>first the constraint functions</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_con; i++)</div><div class="line">    c[i] = fvals[i];</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (*mode &gt; 0) {</div></div><!-- fragment --><p>next, the constraint gradients</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_con*n_vars; i++)</div><div class="line">            cJac[i] = grads[i];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (obj &gt; 1.e10) *mode = -1;</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="ex_6_main"></a>
Main function</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line"></div><div class="line">    libMesh::LibMeshInit init(argc, argv);</div><div class="line"></div><div class="line">    MAST::Examples::GetPotWrapper</div><div class="line">    input(argc, argv, <span class="stringliteral">&quot;input&quot;</span>);</div><div class="line"></div><div class="line">    TopologyOptimizationSIMP2D top_opt(init.comm(), input);</div><div class="line">    _my_func_eval = &amp;top_opt;</div></div><!-- fragment --><p> <a class="el" href="class_m_a_s_t_1_1_n_l_opt_optimization_interface.html">MAST::NLOptOptimizationInterface</a> optimizer(NLOPT_LD_SLSQP); </p><div class="fragment"><div class="line">std::unique_ptr&lt;MAST::OptimizationInterface&gt;</div><div class="line">optimizer;</div><div class="line"></div><div class="line">std::string</div><div class="line">s          = input(<span class="stringliteral">&quot;optimizer&quot;</span>, <span class="stringliteral">&quot;optimizer to use in the example&quot;</span>, <span class="stringliteral">&quot;gcmma&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;gcmma&quot;</span>) {</div><div class="line"></div><div class="line">    optimizer.reset(<span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_g_c_m_m_a_optimization_interface.html">MAST::GCMMAOptimizationInterface</a>);</div><div class="line">    </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    max_inner_iters        = input(<span class="stringliteral">&quot;max_inner_iters&quot;</span>, <span class="stringliteral">&quot;maximum inner iterations in GCMMA&quot;</span>, 15);</div><div class="line">    </div><div class="line">    <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">    constr_penalty         = input(<span class="stringliteral">&quot;constraint_penalty&quot;</span>, <span class="stringliteral">&quot;constraint penalty in GCMMA&quot;</span>, 50.),</div><div class="line">    initial_rel_step       = input(<span class="stringliteral">&quot;initial_rel_step&quot;</span>, <span class="stringliteral">&quot;initial step size in GCMMA&quot;</span>, 1.e-2),</div><div class="line">    asymptote_reduction    = input(<span class="stringliteral">&quot;asymptote_reduction&quot;</span>, <span class="stringliteral">&quot;reduction of aymptote in GCMMA&quot;</span>, 0.7),</div><div class="line">    asymptote_expansion    = input(<span class="stringliteral">&quot;asymptote_expansion&quot;</span>, <span class="stringliteral">&quot;expansion of asymptote in GCMMA&quot;</span>, 1.2);</div><div class="line">    </div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;constraint_penalty&quot;</span>,  constr_penalty);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;initial_rel_step&quot;</span>,  initial_rel_step);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;asymptote_reduction&quot;</span>,  asymptote_reduction);</div><div class="line">    optimizer-&gt;set_real_parameter   (<span class="stringliteral">&quot;asymptote_expansion&quot;</span>,  asymptote_expansion);</div><div class="line">    optimizer-&gt;set_integer_parameter(   <span class="stringliteral">&quot;max_inner_iters&quot;</span>, max_inner_iters);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;snopt&quot;</span>) {</div><div class="line">    </div><div class="line">    optimizer.reset(<span class="keyword">new</span> <a class="code" href="class_m_a_s_t_1_1_n_p_s_o_l_optimization_interface.html">MAST::NPSOLOptimizationInterface</a>);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">    libMesh::out</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Unrecognized optimizer specified: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    libmesh_error();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (optimizer.get()) {</div><div class="line">    </div><div class="line">    optimizer-&gt;attach_function_evaluation_object(top_opt);</div></div><!-- fragment --><p> std::vector&lt;Real&gt; xx1(top_opt.n_vars()), xx2(top_opt.n_vars()); top_opt.init_dvar(xx1, xx2, xx2); top_opt.verify_gradients(xx1); </p><div class="fragment"><div class="line">    optimizer-&gt;optimize();</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="TutorialsPage.html">Tutorials for MAST</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
