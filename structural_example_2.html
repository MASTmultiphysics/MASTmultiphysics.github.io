<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAST: Nonlinear plate bending with continuation solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structural_example_2.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Nonlinear plate bending with continuation solver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example computes the nonlinaer deformation of a curved plate with a temperature and pressure load using path continuation solver.</p>
<p>For direct solver, run with options: -ksp_type preonly -pc_type lu</p>
<p>Initialize libMesh library. </p><div class="fragment"><div class="line">libMesh::LibMeshInit init(argc, argv);</div></div><!-- fragment --><p> wapper to GetPot used to read in values for parameters </p><div class="fragment"><div class="line">MAST::Examples::GetPotWrapper</div><div class="line">input(argc, argv, <span class="stringliteral">&quot;input&quot;</span>);</div></div><!-- fragment --><p> Create Mesh object on default MPI communicator and generate a 2D mesh of QUAD4 elements. We discretize with 12 elements in the x-direction (0.0 to 36.0 inches) and 40 elements in the y-direction (0.0 to 120.0 inches). Note that in libMesh, all meshes are parallel by default in the sense that the equations on the mesh are solved in parallel by PETSc. A "ReplicatedMesh" is one where all MPI processes have the full mesh in memory, as compared to a "DistributedMesh" where the mesh is "chunked" up and distributed across processes, each having their own piece. </p><div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">length = input(<span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;length of the plate&quot;</span> ,.508),</div><div class="line">width  = input(<span class="stringliteral">&quot;width&quot;</span>, <span class="stringliteral">&quot;length of the plate&quot;</span>  ,.508),</div><div class="line">R      = input(<span class="stringliteral">&quot;radius&quot;</span>, <span class="stringliteral">&quot;radius of the circle where the circumference defines the curved plate&quot;</span>, 2.540);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">nx     = input(<span class="stringliteral">&quot;nx&quot;</span>, <span class="stringliteral">&quot;number of elements along the x-axis&quot;</span> , 20),</div><div class="line">ny     = input(<span class="stringliteral">&quot;ny&quot;</span>, <span class="stringliteral">&quot;number of elements along the y-axis&quot;</span> , 20);</div><div class="line"></div><div class="line">libMesh::ReplicatedMesh mesh(init.comm());</div><div class="line">libMesh::MeshTools::Generation::build_square(mesh, nx, ny, 0.0, length, 0.0, width, libMesh::QUAD9);</div><div class="line">mesh.print_info();</div></div><!-- fragment --><p> get the node for which the displacement will be written to the load.txt file. </p><div class="fragment"><div class="line">libMesh::Point</div><div class="line">pt(length/2., width/2., 0.), <span class="comment">// location of mid-point before shift</span></div><div class="line">pt0,</div><div class="line">dr1, dr2;</div><div class="line"><span class="keyword">const</span> libMesh::Node</div><div class="line">*nd = <span class="keyword">nullptr</span>;</div></div><!-- fragment --><p> if a finite radius is defined, change the mesh to a circular arc of specified radius </p><div class="fragment"><div class="line">libMesh::MeshBase::node_iterator</div><div class="line">n_it   = mesh.nodes_begin(),</div><div class="line">n_end  = mesh.nodes_end();</div></div><!-- fragment --><p> initialize the pointer to a node </p><div class="fragment"><div class="line">nd   = *n_it;</div><div class="line">pt0  = *nd;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( ; n_it != n_end; n_it++) {</div><div class="line">    </div><div class="line">    dr1  = pt0;</div><div class="line">    dr1 -= pt;</div><div class="line">    </div><div class="line">    dr2  = **n_it;</div><div class="line">    dr2 -= pt;</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (dr2.norm() &lt; dr1.norm()) {</div><div class="line"></div><div class="line">        nd  = *n_it;</div><div class="line">        pt0 = *nd;</div><div class="line">    }</div></div><!-- fragment --><p> compute angle based on y-location </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (R &gt; 0.) {</div><div class="line">        <a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a> a  = asin(((**n_it)(1)-width*.5)/R);</div><div class="line">        (**n_it)(2) = cos(a)*R;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">std::cout &lt;&lt; *nd &lt;&lt; std::endl;</div></div><!-- fragment --><p> also, create a boundary id for this node since we will constrain the x-displacement here </p><div class="fragment"><div class="line">mesh.boundary_info-&gt;add_node(nd, 6);</div><div class="line">mesh.boundary_info-&gt;sideset_name(6) = <span class="stringliteral">&quot;mid_node&quot;</span>;</div><div class="line">mesh.prepare_for_use();</div></div><!-- fragment --><p> For later reference, the boundary and subdomain ID's generated by the libMesh mesh generation are sketched below.</p>
<pre class="fragment">*         y               (#) Boundary ID 
*         | (2)           [#] Subdomain ID 
*   120.0 O-----O 
*         |     |          x - right 
*         |     |          y - up 
*     (3) | [0] | (1)      z - out of screen 
*         |     | 
*         |     | 
*     0.0 O-----O--x 
*           (0) 
*        0.0   36.0 
*  </pre><p>Create EquationSystems object, which is a container for multiple systems of equations that are defined on a given mesh. </p><div class="fragment"><div class="line">libMesh::EquationSystems equation_systems(mesh);</div></div><!-- fragment --><p> Add system of type <a class="el" href="class_m_a_s_t_1_1_nonlinear_system.html" title="This class implements a system for solution of nonlinear systems. ">MAST::NonlinearSystem</a> (which wraps libMesh::NonlinearImplicitSystem) to the EquationSystems container. We name the system "structural" and also get a reference to the system so we can easily reference it later. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a> &amp; system = equation_systems.add_system&lt;<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&gt;(<span class="stringliteral">&quot;structural&quot;</span>);</div></div><!-- fragment --><p> Create a finite element type for the system. Here we use first order Lagrangian-type finite elements. </p><div class="fragment"><div class="line">libMesh::FEType fetype(libMesh::SECOND, libMesh::LAGRANGE);</div></div><!-- fragment --><p> Initialize the system to the correct set of variables for a structural analysis. In libMesh this is analogous to adding variables (each with specific finite element type/order to the system for a particular system of equations. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_system_initialization.html">MAST::StructuralSystemInitialization</a> structural_system(system,</div><div class="line">                                                       system.name(),</div><div class="line">                                                       fetype);</div></div><!-- fragment --><p> Initialize a new structural discipline using equation_systems. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_physics_discipline_base.html">MAST::PhysicsDisciplineBase</a> discipline(equation_systems);</div></div><!-- fragment --><p> Create and add boundary conditions to the structural system. A Dirichlet BC adds fixed displacement BCs. Here we use the side boundary ID numbering created by the libMesh generator to clamp the edge of the mesh along x=0.0. We apply the simply supported BC on bottom and top. For clamped edges, set vars={0, 1, 2, 3, 4, 5, 6}. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html">MAST::DirichletBoundaryCondition</a> clamped_edge0, clamped_edge1, clamped_edge2, clamped_edge3;    <span class="comment">// Create BC object.</span></div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">vars   = {1, 2},</div><div class="line">vars_x = {0};</div><div class="line">clamped_edge0.<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(0, vars);   <span class="comment">// Assign boundary ID and variables to constrain</span></div><div class="line">clamped_edge1.<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(6, vars_x);   <span class="comment">// Assign boundary ID and variables to constrain</span></div><div class="line">clamped_edge2.<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(2, vars);   <span class="comment">// Assign boundary ID and variables to constrain</span></div><div class="line">clamped_edge3.<a class="code" href="class_m_a_s_t_1_1_dirichlet_boundary_condition.html#a7fe64cf8537780d8b6c89294e3dc3cde">init</a>(3, vars);   <span class="comment">// Assign boundary ID and variables to constrain</span></div></div><!-- fragment --><p> this applies the simply supported condition to the bottom (bid=0) and top (bid=1) edges. For setting conditions to left (bid=3) and right (bid=1) call the method with the respective boundary ids. </p><div class="fragment"><div class="line">discipline.add_dirichlet_bc(0, clamped_edge0);     <span class="comment">// Attach boundary condition to discipline</span></div><div class="line">discipline.add_dirichlet_bc(6, clamped_edge1);     <span class="comment">// Attach boundary condition to discipline</span></div><div class="line">discipline.add_dirichlet_bc(2, clamped_edge2);     <span class="comment">// Attach boundary condition to discipline</span></div></div><!-- fragment --><p> discipline.add_dirichlet_bc(3, clamped_edge3); // Attach boundary condition to discipline </p><div class="fragment"><div class="line">discipline.init_system_dirichlet_bc(system);      <span class="comment">// Initialize the BC in the system.</span></div></div><!-- fragment --><p> Initialize the equation system since we now know the size of our system matrices (based on mesh, element type, variables in the structural_system) as well as the setup of dirichlet boundary conditions. This initialization process is basically a pre-processing step to preallocate storage and spread it across processors. </p><div class="fragment"><div class="line">equation_systems.init();</div><div class="line">equation_systems.print_info();</div></div><!-- fragment --><p> Create parameters. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> thickness  (<span class="stringliteral">&quot;th&quot;</span>,    input(   <span class="stringliteral">&quot;th&quot;</span>,      <span class="stringliteral">&quot;plate thickness&quot;</span>,              .0127));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> E          (<span class="stringliteral">&quot;E&quot;</span>,     input(    <span class="stringliteral">&quot;E&quot;</span>,      <span class="stringliteral">&quot;Young&#39;s modulus&quot;</span>,          3.10275e9));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> nu         (<span class="stringliteral">&quot;nu&quot;</span>,    input(   <span class="stringliteral">&quot;nu&quot;</span>,     <span class="stringliteral">&quot;Poission&#39;s ratio&quot;</span>,                 .3));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> rho        (<span class="stringliteral">&quot;rho&quot;</span>,   input(  <span class="stringliteral">&quot;rho&quot;</span>,     <span class="stringliteral">&quot;material density&quot;</span>,        0.1*0.00259));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> kappa      (<span class="stringliteral">&quot;kappa&quot;</span>, input(<span class="stringliteral">&quot;kappa&quot;</span>,          <span class="stringliteral">&quot;shear correction factor&quot;</span>,  5./6.));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> alpha      (<span class="stringliteral">&quot;alpha&quot;</span>, input(<span class="stringliteral">&quot;alpha&quot;</span>, <span class="stringliteral">&quot;coefficient of thermal expansion&quot;</span>, 1.5e-5));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> zero       (<span class="stringliteral">&quot;zero&quot;</span>, 0.0);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> pressure   (<span class="stringliteral">&quot;p&quot;</span>,     input(    <span class="stringliteral">&quot;p&quot;</span>,     <span class="stringliteral">&quot;initial point load&quot;</span>,                0));</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_parameter.html">MAST::Parameter</a> temperature(<span class="stringliteral">&quot;T&quot;</span>,     input( <span class="stringliteral">&quot;temp&quot;</span>,  <span class="stringliteral">&quot;initial temperature&quot;</span>,                0.0));</div></div><!-- fragment --><p> Create ConstantFieldFunctions used to spread parameters throughout the model. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> th_f(<span class="stringliteral">&quot;h&quot;</span>, thickness);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> E_f(<span class="stringliteral">&quot;E&quot;</span>, E);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> nu_f(<span class="stringliteral">&quot;nu&quot;</span>, nu);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> rho_f(<span class="stringliteral">&quot;rho&quot;</span>, rho);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> kappa_f(<span class="stringliteral">&quot;kappa&quot;</span>, kappa);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> alpha_f(<span class="stringliteral">&quot;alpha_expansion&quot;</span>, alpha);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> off_f(<span class="stringliteral">&quot;off&quot;</span>, zero);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> temperature_f(<span class="stringliteral">&quot;temperature&quot;</span>, temperature);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_constant_field_function.html">MAST::ConstantFieldFunction</a> ref_temp_f(<span class="stringliteral">&quot;ref_temperature&quot;</span>, zero);</div><div class="line">PointLoad load_f(pressure);</div></div><!-- fragment --><p> Initialize point load. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_point_load_condition.html">MAST::PointLoadCondition</a> point_load(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14a1c34f01cde879211fc7a5c196fdc4cc9">MAST::POINT_LOAD</a>);</div><div class="line">point_load.add(load_f);</div><div class="line">point_load.add_node(*nd);</div><div class="line">discipline.add_point_load(point_load);</div><div class="line"></div><div class="line"><a class="code" href="class_m_a_s_t_1_1_boundary_condition_base.html">MAST::BoundaryConditionBase</a> temperature_load(<a class="code" href="namespace_m_a_s_t.html#aad73c2614379df860d42999aa0811e14a86f299c7a235fa4f58e87c412e209079">MAST::TEMPERATURE</a>);</div><div class="line">temperature_load.add(temperature_f);</div><div class="line">temperature_load.add(ref_temp_f);</div><div class="line">discipline.add_volume_load(0, temperature_load);</div></div><!-- fragment --><p> Create the material property card ("card" is NASTRAN lingo) and the relevant parameters to it. An isotropic material needs elastic modulus (E) and Poisson ratio (nu) to describe its behavior. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_isotropic_material_property_card.html">MAST::IsotropicMaterialPropertyCard</a> material;</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(E_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(nu_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(kappa_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(alpha_f);</div><div class="line">material.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(rho_f);</div></div><!-- fragment --><p> Create the section property card. Attach all property values. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html">MAST::Solid2DSectionElementPropertyCard</a> section;</div><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(th_f);</div><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_function_set_base.html#a1c62b64f2321709d3f238290040275db">add</a>(off_f);</div><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_element_property_card_base.html#a80330fb382ca84dc060eeb7ca6b784c6">set_strain</a>(<a class="code" href="namespace_m_a_s_t.html#af0d815f953a3c27690fda4e2748b357daca95d2120f66aa88bd88a58f0d76c4ed">MAST::NONLINEAR_STRAIN</a>);</div></div><!-- fragment --><p> Attach material to the card. </p><div class="fragment"><div class="line">section.<a class="code" href="class_m_a_s_t_1_1_solid2_d_section_element_property_card.html#a902ba3f2c2a23289a7c394ccb8cc8162">set_material</a>(material);</div></div><!-- fragment --><p> Initialize the specify the subdomain in the mesh that it applies to. </p><div class="fragment"><div class="line">discipline.set_property_for_subdomain(0, section);</div></div><!-- fragment --><p> Create nonlinear assembly object and set the discipline and structural_system. Create reference to system. </p><div class="fragment"><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_implicit_assembly.html">MAST::NonlinearImplicitAssembly</a> assembly;</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_structural_nonlinear_assembly_elem_operations.html">MAST::StructuralNonlinearAssemblyElemOperations</a> elem_ops;</div><div class="line">assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#a0644e12cd53adc64d9b7e027becc08b5">set_discipline_and_system</a>(discipline, structural_system);</div><div class="line">elem_ops.<a class="code" href="class_m_a_s_t_1_1_assembly_elem_operations.html#affb65f707a71004834a34987f14749c5">set_discipline_and_system</a>(discipline, structural_system);</div><div class="line"><a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html">MAST::NonlinearSystem</a>&amp; nonlinear_system = assembly.<a class="code" href="class_m_a_s_t_1_1_assembly_base.html#abdff8292b4929a3aa7276c639a8d05e3">system</a>();</div></div><!-- fragment --><p> Zero the solution before solving. </p><div class="fragment"><div class="line">nonlinear_system.solution-&gt;zero();</div></div><!-- fragment --><p> Write output to Exodus. </p><div class="fragment"><div class="line">libMesh::ExodusII_IO exodus_io(mesh);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">dof_num = nd-&gt;dof_number(0, 2, 0);</div></div><!-- fragment --><p> Solve the system and print displacement degrees-of-freedom to screen. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">n_temp_steps  = input( <span class="stringliteral">&quot;n_temp_steps&quot;</span>, <span class="stringliteral">&quot;number of load steps for temperature increase&quot;</span>,  10),</div><div class="line">n_press_steps = input(<span class="stringliteral">&quot;n_press_steps&quot;</span>,    <span class="stringliteral">&quot;number of load steps for pressure increase&quot;</span>,  30);</div></div><!-- fragment --><p> write the header to the load.txt file </p><div class="fragment"><div class="line"><a class="code" href="mast__data__types_8h.html#a0fc21c6ff882da286a44d42c85f5378f">Real</a></div><div class="line">max_temp = input(<span class="stringliteral">&quot;max_temp&quot;</span>, <span class="stringliteral">&quot;maximum temperature&quot;</span>, 0.),</div><div class="line">dt = 1./(n_temp_steps+n_press_steps-1.);</div><div class="line">std::ofstream out;</div><div class="line"><span class="keywordflow">if</span> (mesh.comm().rank() == 0) {</div><div class="line">    out.open(<span class="stringliteral">&quot;load.txt&quot;</span>, std::ofstream::out);</div><div class="line">    out</div><div class="line">    &lt;&lt; std::setw(10) &lt;&lt; <span class="stringliteral">&quot;iter&quot;</span></div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; <span class="stringliteral">&quot;temperature&quot;</span></div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; <span class="stringliteral">&quot;pressure&quot;</span></div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; <span class="stringliteral">&quot;displ&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> first solve the the temperature increments </p><div class="fragment"><div class="line">std::vector&lt;Real&gt; vec1;</div><div class="line">std::vector&lt;unsigned int&gt; vec2 = {dof_num};</div><div class="line"><span class="keywordflow">if</span> (n_temp_steps) {</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_pseudo_arclength_continuation_solver.html">MAST::PseudoArclengthContinuationSolver</a> solver;</div><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a81321bdc20b5e491976904f669f00ee8">schur_factorization</a> = input(<span class="stringliteral">&quot;if_schur_factorization&quot;</span>, <span class="stringliteral">&quot;use Schur-factorization in continuation solver&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a67bbbf2f1c0520db2a71ab5345b97dc2">min_step</a>            = input(<span class="stringliteral">&quot;min_step&quot;</span>, <span class="stringliteral">&quot;minimum arc-length step-size for continuation solver&quot;</span>,          10.);</div></div><!-- fragment --><p> specify temperature as the load parameter to be changed per load step </p><div class="fragment"><div class="line">solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a5afe46ebb68fe8872e651974ece78384">set_assembly_and_load_parameter</a>(elem_ops, assembly, temperature);</div></div><!-- fragment --><p> the initial deformation direction is identified with a unit change in temperature. </p><div class="fragment"><div class="line">solver.<a class="code" href="class_m_a_s_t_1_1_pseudo_arclength_continuation_solver.html#abd937654fdd29d07d719e6e3c855d04f">initialize</a>(temperature());</div></div><!-- fragment --><p> with the search direction defined, we define the arc length per load step to be a factor of 2 greater than the initial step. </p><div class="fragment"><div class="line">solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#ad85b6542eb3b6d922e4e32ec771578f2">arc_length</a> *= 2;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_temp_steps; i++) {</div><div class="line"></div><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#aa88123f4554d2394aa3b112063179c6d">solve</a>();</div><div class="line">    libMesh::out</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;  iter: &quot;</span> &lt;&lt; i</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;  temperature: &quot;</span> &lt;&lt; temperature()</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;  pressure: &quot;</span>    &lt;&lt; pressure() &lt;&lt; std::endl;</div></div><!-- fragment --><p> get the value of the node at the center of the plate for output </p><div class="fragment"><div class="line">system.solution-&gt;localize(vec1, vec2);</div></div><!-- fragment --><p> write the value to the load.txt file </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (mesh.comm().rank() == 0) {</div><div class="line">    out</div><div class="line">    &lt;&lt; std::setw(10) &lt;&lt; i</div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; temperature()</div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; pressure()</div><div class="line">    &lt;&lt; std::setw(25) &lt;&lt; vec1[0] &lt;&lt; std::endl;</div><div class="line">}</div><div class="line">system.time += dt;</div></div><!-- fragment --><p> write the current solution to the exodus file for visualization </p><div class="fragment"><div class="line">        exodus_io.write_timestep(<span class="stringliteral">&quot;ex3_plate_static.exo&quot;</span>,</div><div class="line">                                 equation_systems,</div><div class="line">                                 i+1,</div><div class="line">                                 system.time);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (temperature() &gt; max_temp) {</div><div class="line">            temperature = max_temp;</div><div class="line">            nonlinear_system.<a class="code" href="class_m_a_s_t_1_1_nonlinear_system.html#aaaed1f33d18591f0f380516e1e2fbb8c">solve</a>(elem_ops, assembly);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> next, solve the the pressure increments </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (n_press_steps) {</div><div class="line">    </div><div class="line">    <a class="code" href="class_m_a_s_t_1_1_pseudo_arclength_continuation_solver.html">MAST::PseudoArclengthContinuationSolver</a> solver;</div><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a81321bdc20b5e491976904f669f00ee8">schur_factorization</a> = input(<span class="stringliteral">&quot;if_schur_factorization&quot;</span>, <span class="stringliteral">&quot;use Schur-factorization in continuation solver&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a67bbbf2f1c0520db2a71ab5345b97dc2">min_step</a>            = input(<span class="stringliteral">&quot;min_step&quot;</span>, <span class="stringliteral">&quot;minimum arc-length step-size for continuation solver&quot;</span>,          10.);</div></div><!-- fragment --><p> specify pressure as the load parameter to be changed per load step </p><div class="fragment"><div class="line">solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#a5afe46ebb68fe8872e651974ece78384">set_assembly_and_load_parameter</a>(elem_ops, assembly, pressure);</div></div><!-- fragment --><p> initial search direction is defined usign a pressure of 2e3. </p><div class="fragment"><div class="line">solver.<a class="code" href="class_m_a_s_t_1_1_pseudo_arclength_continuation_solver.html#abd937654fdd29d07d719e6e3c855d04f">initialize</a>(-1.e1);</div></div><!-- fragment --><p> the arch length is chanegd to a factor of 4 for each load step. </p><div class="fragment"><div class="line">    solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#ad85b6542eb3b6d922e4e32ec771578f2">arc_length</a> *= 10;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0+n_temp_steps; i&lt;n_press_steps+n_temp_steps; i++) {</div><div class="line">        solver.<a class="code" href="class_m_a_s_t_1_1_continuation_solver_base.html#aa88123f4554d2394aa3b112063179c6d">solve</a>();</div><div class="line">        std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;  iter: &quot;</span> &lt;&lt; i</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;  temperature: &quot;</span> &lt;&lt; temperature()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;  pressure: &quot;</span>    &lt;&lt; pressure() &lt;&lt; std::endl;</div><div class="line">        system.solution-&gt;localize(vec1, vec2);</div><div class="line">        <span class="keywordflow">if</span> (mesh.comm().rank() == 0) {</div><div class="line">            out</div><div class="line">            &lt;&lt; std::setw(10) &lt;&lt; i</div><div class="line">            &lt;&lt; std::setw(25) &lt;&lt; temperature()</div><div class="line">            &lt;&lt; std::setw(25) &lt;&lt; pressure()</div><div class="line">            &lt;&lt; std::setw(25) &lt;&lt; vec1[0] &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        system.time += dt;</div><div class="line">        exodus_io.write_timestep(<span class="stringliteral">&quot;ex3_plate_static.exo&quot;</span>,</div><div class="line">                                 equation_systems,</div><div class="line">                                 i+1,</div><div class="line">                                 system.time);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="TutorialsPage.html">Tutorials for MAST</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
